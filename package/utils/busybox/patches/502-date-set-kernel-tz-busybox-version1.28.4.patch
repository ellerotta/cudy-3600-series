--- a/coreutils/date.c
+++ a/coreutils/date.c
@@ -19,7 +19,7 @@
    much as possible, missed out a lot of bounds checking */
 
 //config:config DATE
-//config:	bool "date (7 kb)"
+//config:	bool "date (7.1 kb)"
 //config:	default y
 //config:	help
 //config:	date is used to set the system date or display the
@@ -33,10 +33,12 @@
 //config:	Enable option (-I) to output an ISO-8601 compliant
 //config:	date/time string.
 //config:
+//config:# defaults to "no": stat's nanosecond field is a bit non-portable
 //config:config FEATURE_DATE_NANO
 //config:	bool "Support %[num]N nanosecond format specifier"
-//config:	default n # stat's nanosecond field is a bit non-portable
+//config:	default n  # syscall(__NR_clock_gettime)
 //config:	depends on DATE
+//config:	select PLATFORM_LINUX
 //config:	help
 //config:	Support %[num]N format specifier. Adds ~250 bytes of code.
 //config:
@@ -52,7 +54,7 @@
 //config:	date -s (and other commands like touch -d) use more sensible
 //config:	formats (for one, ISO format YYYY-MM-DD hh:mm:ss.ssssss).
 //config:
-//config:	With this option off, 'date DATE' and 'date -s DATE' support
+//config:	With this option off, 'date DATE' is 'date -s DATE' support
 //config:	the same format. With it on, 'date DATE' additionally supports
 //config:	MMDDhhmm[[YY]YY][.ss] format.
 
@@ -93,25 +95,37 @@
  */
 
 //usage:#define date_trivial_usage
-//usage:       "[OPTIONS] [+FMT] [[-s] TIME]"
+//usage:       "[OPTIONS] [+FMT] [TIME]"
 //usage:#define date_full_usage "\n\n"
 //usage:       "Display time (using +FMT), or set time\n"
-//usage:     "\n	-u		Work in UTC (don't convert to local time)"
+//usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	[-s] TIME	Set time to TIME"
-//usage:     "\n	-d TIME		Display TIME, not 'now'"
+//usage:     "\n	-u		Work in UTC (don't convert to local time)"
+//usage:     "\n	-R		Output RFC-2822 compliant date string"
+//usage:	) IF_LONG_OPTS(
+//usage:     "\n	[-s,--set] TIME	Set time to TIME"
+//usage:     "\n	-u,--utc	Work in UTC (don't convert to local time)"
+//usage:     "\n	-R,--rfc-2822	Output RFC-2822 compliant date string"
+//usage:	)
 //usage:	IF_FEATURE_DATE_ISOFMT(
-//usage:     "\n	-D FMT		FMT (strptime format) for -s/-d TIME conversion"
-////////^^^^^^^^^^^^^^^^^^^^^^ busybox invention, not compat
+//usage:     "\n	-I[SPEC]	Output ISO-8601 compliant date string"
+//usage:     "\n			SPEC='date' (default) for date only,"
+//usage:     "\n			'hours', 'minutes', or 'seconds' for date and"
+//usage:     "\n			time to the indicated precision"
 //usage:	)
+//usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	-r FILE		Display last modification time of FILE"
-//usage:     "\n	-R		Output RFC-2822 date"
+//usage:     "\n	-d TIME		Display TIME, not 'now'"
+//usage:	) IF_LONG_OPTS(
+//usage:     "\n	-r,--reference FILE	Display last modification time of FILE"
+//usage:     "\n	-d,--date TIME	Display TIME, not 'now'"
+//usage:	)
 //usage:	IF_FEATURE_DATE_ISOFMT(
-//usage:     "\n	-I[SPEC]	Output ISO-8601 date"
-//usage:     "\n			SPEC=date (default), hours, minutes, seconds or ns"
+//usage:     "\n	-D FMT		Use FMT for -d TIME conversion"
 //usage:	)
+//usage:     "\n	-k		Set Kernel timezone from localtime and exit"
 //usage:     "\n"
 //usage:     "\nRecognized TIME formats:"
-//usage:     "\n	@seconds_since_1970"
 //usage:     "\n	hh:mm[:ss]"
 //usage:     "\n	[YYYY.]MM.DD-hh:mm[:ss]"
 //usage:     "\n	YYYY-MM-DD hh:mm[:ss]"
@@ -126,9 +140,8 @@
 
 #include "libbb.h"
 #include "common_bufsiz.h"
-#if ENABLE_FEATURE_DATE_NANO
-# include <sys/syscall.h>
-#endif
+#include <sys/time.h>
+#include <sys/syscall.h>
 
 enum {
 	OPT_RFC2822   = (1 << 0), /* R */
@@ -136,8 +149,9 @@ enum {
 	OPT_UTC       = (1 << 2), /* u */
 	OPT_DATE      = (1 << 3), /* d */
 	OPT_REFERENCE = (1 << 4), /* r */
-	OPT_ISO8601   = (1 << 5) * ENABLE_FEATURE_DATE_ISOFMT, /* I */
-	OPT_STR2DT    = (1 << 6) * ENABLE_FEATURE_DATE_ISOFMT, /* D */
+	OPT_KERNELTZ  = (1 << 5), /* k */
+	OPT_TIMESPEC  = (1 << 6) * ENABLE_FEATURE_DATE_ISOFMT, /* I */
+	OPT_HINT      = (1 << 7) * ENABLE_FEATURE_DATE_ISOFMT, /* D */
 };
 
 #if ENABLE_LONG_OPTS
@@ -149,6 +163,7 @@ static const char date_longopts[] ALIGN1
 	/*	"universal\0" No_argument       "u" */
 		"date\0"      Required_argument "d"
 		"reference\0" Required_argument "r"
+		"set-kernel-tz\0" No_argument   "k"
 		;
 #endif
 
@@ -159,14 +174,22 @@ static const char date_longopts[] ALIGN1
  * - after xasprintf we use other xfuncs
  */
 
+static void maybe_set_utc(int opt)
+{
+	if (opt & OPT_UTC)
+		putenv((char*)"TZ=UTC0");
+}
+
 int date_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int date_main(int argc UNUSED_PARAM, char **argv)
 {
+	time_t tt;
+	struct timezone tz;
 	struct timespec ts;
 	struct tm tm_time;
 	char buf_fmt_dt2str[64];
 	unsigned opt;
-	int isofmt = -1;
+	int ifmt = -1;
 	char *date_str;
 	char *fmt_dt2str;
 	char *fmt_str2dt;
@@ -174,7 +197,7 @@ int date_main(int argc UNUSED_PARAM, cha
 	char *isofmt_arg = NULL;
 
 	opt = getopt32long(argv, "^"
-			"Rs:ud:r:"
+			"Rs:ud:r:k"
 			IF_FEATURE_DATE_ISOFMT("I::D:")
 			"\0"
 			"d--s:s--d"
@@ -185,16 +208,15 @@ int date_main(int argc UNUSED_PARAM, cha
 	);
 	argv += optind;
 
-	if (opt & OPT_UTC)
-		putenv((char*)"TZ=UTC0");
+	maybe_set_utc(opt);
 
-	if (ENABLE_FEATURE_DATE_ISOFMT && (opt & OPT_ISO8601)) {
-		isofmt = 0; /* default is date */
+	if (ENABLE_FEATURE_DATE_ISOFMT && (opt & OPT_TIMESPEC)) {
+		ifmt = 0; /* default is date */
 		if (isofmt_arg) {
 			static const char isoformats[] ALIGN1 =
-				"date\0""hours\0""minutes\0""seconds\0ns\0";
-			isofmt = index_in_substrings(isoformats, isofmt_arg);
-			if (isofmt < 0)
+				"date\0""hours\0""minutes\0""seconds\0"; /* ns? */
+			ifmt = index_in_substrings(isoformats, isofmt_arg);
+			if (ifmt < 0)
 				bb_show_usage();
 		}
 	}
@@ -204,7 +226,7 @@ int date_main(int argc UNUSED_PARAM, cha
 		fmt_dt2str = &argv[0][1]; /* skip over the '+' */
 		argv++;
 	}
-	if (!(opt & (OPT_SET | OPT_DATE))) { /* neither -s TIME nor -d TIME? */
+	if (!(opt & (OPT_SET | OPT_DATE))) {
 		opt |= OPT_SET;
 		date_str = argv[0]; /* can be NULL */
 		if (date_str) {
@@ -238,6 +260,31 @@ int date_main(int argc UNUSED_PARAM, cha
 	if (*argv)
 		bb_show_usage();
 
+	/* Setting of kernel timezone was requested */
+	if (opt & OPT_KERNELTZ) {
+		tt = time(NULL);
+		localtime_r(&tt, &tm_time);
+
+		/* workaround warp_clock() on first invocation */
+		memset(&tz, 0, sizeof(tz));
+		syscall(SYS_settimeofday, NULL, &tz);
+
+		memset(&tz, 0, sizeof(tz));
+#ifdef __USE_MISC
+		tz.tz_minuteswest = -(tm_time.tm_gmtoff / 60);
+#else
+		tz.tz_minuteswest = -(tm_time.__tm_gmtoff / 60);
+#endif
+
+		if (syscall(SYS_settimeofday, NULL, &tz))
+		{
+			bb_perror_msg("can't set kernel time zone");
+			return EXIT_FAILURE;
+		}
+
+		return EXIT_SUCCESS;
+	}
+
 	/* Now we have parsed all the information except the date format
 	 * which depends on whether the clock is being set or read */
 
@@ -254,14 +301,13 @@ int date_main(int argc UNUSED_PARAM, cha
 #endif
 	} else {
 #if ENABLE_FEATURE_DATE_NANO
-		clock_gettime(CLOCK_REALTIME, &ts);
+		/* libc has incredibly messy way of doing this,
+		 * typically requiring -lrt. We just skip all this mess */
+		syscall(__NR_clock_gettime, CLOCK_REALTIME, &ts);
 #else
 		time(&ts.tv_sec);
 #endif
 	}
-#if !ENABLE_FEATURE_DATE_NANO
-	ts.tv_nsec = 0;
-#endif
 	localtime_r(&ts.tv_sec, &tm_time);
 
 	/* If date string is given, update tm_time, and maybe set date */
@@ -272,7 +318,7 @@ int date_main(int argc UNUSED_PARAM, cha
 		tm_time.tm_hour = 0;
 
 		/* Process any date input to UNIX time since 1 Jan 1970 */
-		if (ENABLE_FEATURE_DATE_ISOFMT && (opt & OPT_STR2DT)) {
+		if (ENABLE_FEATURE_DATE_ISOFMT && (opt & OPT_HINT)) {
 			if (strptime(date_str, fmt_str2dt, &tm_time) == NULL)
 				bb_error_msg_and_die(bb_msg_invalid_date, date_str);
 		} else {
@@ -284,11 +330,10 @@ int date_main(int argc UNUSED_PARAM, cha
 		if (date_str[0] != '@')
 			tm_time.tm_isdst = -1;
 		ts.tv_sec = validate_tm_time(date_str, &tm_time);
-		ts.tv_nsec = 0;
 
 		/* if setting time, set it */
-		if ((opt & OPT_SET) && clock_settime(CLOCK_REALTIME, &ts) < 0) {
-			bb_simple_perror_msg("can't set date");
+		if ((opt & OPT_SET) && stime(&ts.tv_sec) < 0) {
+			bb_perror_msg("can't set date");
 		}
 	}
 
@@ -298,34 +343,24 @@ int date_main(int argc UNUSED_PARAM, cha
 	if (fmt_dt2str == NULL) {
 		int i;
 		fmt_dt2str = buf_fmt_dt2str;
-		if (ENABLE_FEATURE_DATE_ISOFMT && isofmt >= 0) {
-			/* -I[SPEC]: 0:date 1:hours 2:minutes 3:seconds 4:ns*/
+		if (ENABLE_FEATURE_DATE_ISOFMT && ifmt >= 0) {
+			/* -I[SPEC]: 0:date 1:hours 2:minutes 3:seconds */
 			strcpy(fmt_dt2str, "%Y-%m-%dT%H:%M:%S");
-			i = 8 + 3 * isofmt;
-			if (isofmt != 0) {
-				int n;
-				if (isofmt == 4) {
-					i -= 3;
-					i += sprintf(&fmt_dt2str[i], ",%09u", (unsigned)ts.tv_nsec);
-				}
-				/* %z prints "+hhmm" timezone, but coreutils-8.30 prints "+hh:mm"! */
-				/* ...therefore this atrocity: */
-				n = strftime(&fmt_dt2str[i], 8, "%z", &tm_time);
-				i += n;
-				if (n == 5 && (fmt_dt2str[i-5] == '+' || fmt_dt2str[i-5] == '-')) {
-					/* "mm" -> ":mm" */
-					fmt_dt2str[i    ] = fmt_dt2str[i - 1];
-					fmt_dt2str[i - 1] = fmt_dt2str[i - 2];
-					fmt_dt2str[i - 2] = ':';
-					i++;
-				}
+			i = 8 + 3 * ifmt;
+			if (ifmt != 0) {
+				/* TODO: if (ifmt==4) i += sprintf(&fmt_dt2str[i], ",%09u", nanoseconds); */
+ format_utc:
+				fmt_dt2str[i++] = '%';
+				fmt_dt2str[i++] = (opt & OPT_UTC) ? 'Z' : 'z';
 			}
 			fmt_dt2str[i] = '\0';
 		} else if (opt & OPT_RFC2822) {
 			/* -R. undo busybox.c setlocale */
 			if (ENABLE_LOCALE_SUPPORT)
 				setlocale(LC_TIME, "C");
-			fmt_dt2str = (char*)"%a, %d %b %Y %H:%M:%S %z";
+			strcpy(fmt_dt2str, "%a, %d %b %Y %H:%M:%S ");
+			i = sizeof("%a, %d %b %Y %H:%M:%S ")-1;
+			goto format_utc;
 		} else { /* default case */
 			fmt_dt2str = (char*)"%a %b %e %H:%M:%S %Z %Y";
 		}
@@ -377,6 +412,10 @@ int date_main(int argc UNUSED_PARAM, cha
 		/* With no format string, just print a blank line */
 		date_buf[0] = '\0';
 	} else {
+		/* Handle special conversions */
+		if (is_prefixed_with(fmt_dt2str, "%f")) {
+			fmt_dt2str = (char*)"%Y.%m.%d-%H:%M:%S";
+		}
 		/* Generate output string */
 		strftime(date_buf, COMMON_BUFSIZE, fmt_dt2str, &tm_time);
 	}
