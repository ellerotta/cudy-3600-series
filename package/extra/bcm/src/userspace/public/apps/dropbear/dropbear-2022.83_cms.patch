diff -Naur orig_dropbear-2022.83/common-session.c dropbear-2022.83/common-session.c
--- orig_dropbear-2022.83/common-session.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/common-session.c	2022-11-16 16:27:57.320963708 +0800
@@ -363,6 +363,9 @@
 	writebuf_enqueue(writebuf);
 }
 
+#ifdef DESKTOP_LINUX
+struct passwd fake_passwd = {"admin", "should-be-salted-admin", 0, 0, "admin user", "/", "/bin/sh"};
+#endif
 static void read_session_identification() {
 	/* max length of 255 chars */
 	char linebuf[256];
@@ -627,7 +630,11 @@
 	if (ses.authstate.pw_passwd)
 		m_free(ses.authstate.pw_passwd);
 
+#ifdef DESKTOP_LINUX
+	pw = &fake_passwd;
+#else
 	pw = getpwnam(username);
+#endif
 	if (!pw) {
 		return;
 	}
diff -Naur orig_dropbear-2022.83/dbutil.c dropbear-2022.83/dbutil.c
--- orig_dropbear-2022.83/dbutil.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/dbutil.c	2022-11-16 16:27:57.320963708 +0800
@@ -67,6 +67,18 @@
 #include "session.h"
 #include "atomicio.h"
 
+// BRCM begin
+#ifndef SSHD_GENKEY
+#ifdef BRCM_CMS_BUILD
+#undef BASE64
+#include "cms.h"
+#include "cms_cli.h"
+#include "cms_msg.h"
+void *msgHandle=NULL;
+#endif
+#endif
+// BRCM end
+
 #define MAX_FMT 100
 
 static void generic_dropbear_exit(int exitcode, const char* format, 
@@ -118,7 +130,12 @@
 
 	snprintf(fmtbuf, sizeof(fmtbuf), "Exited: %s", format);
 
-	_dropbear_log(LOG_INFO, fmtbuf, param);
+// BRCM	_dropbear_log(LOG_INFO, fmtbuf, param);
+#if 1 //inetd
+// no need to close, we are about to exit anyways   close(APP_LISTEN_FD);
+//	close(IPC_CONN_FD);
+	unlink(DROPBEAR_PIDFILE);
+#endif
 
 #if DROPBEAR_FUZZ
     if (fuzz.do_jmp) {
@@ -365,6 +382,59 @@
 	}
 }
 
+#ifdef BRCM_CMS_BUILD
+/* run_shell_command source */
+/* Runs a command with "sh -c". Will close FDs (except stdin/stdout/stderr) and
+ * re-enabled SIGPIPE. If cmd is NULL, will run a login shell.
+ */
+void bcm_run_shell_command(const char* cmd, unsigned int maxfd, char* usershell) {
+	char * argv[4];
+	char * baseshell = NULL;
+	unsigned int i;
+
+	baseshell = basename(usershell);
+
+	if (cmd != NULL) {
+		argv[0] = baseshell;
+	} else {
+		/* a login shell should be "-bash" for "/bin/bash" etc */
+		int len = strlen(baseshell) + 2; /* 2 for "-" */
+		argv[0] = (char*)m_malloc(len);
+		snprintf(argv[0], len, "-%s", baseshell);
+	}
+
+	if (cmd != NULL) {
+		argv[1] = "-c";
+		argv[2] = (char*)cmd;
+		argv[3] = NULL;
+	} else {
+		/* construct a shell of the form "-bash" etc */
+		argv[1] = NULL;
+	}
+
+	/* Re-enable SIGPIPE for the executed process */
+	if (signal(SIGPIPE, SIG_DFL) == SIG_ERR) {
+		dropbear_exit("signal() error");
+	}
+
+	/* close file descriptors except stdin/stdout/stderr
+	 * Need to be sure FDs are closed here to avoid reading files as root */
+	for (i = 3; i <= maxfd; i++) {
+			m_close(i);
+	}
+
+	/*
+	* The code in the function has been heavily modified for CMS.
+	* Note that we are not doing an execv of the shell.  Instead,
+	* we stay in the current process, which is still sshd, and just
+	* call into cmsCli_run directly.  So we have to undo the sigchild
+	* setting of the parent.  (There may be other settings we need
+	* to undo that would have been automatically undone if we did the exec.
+	*/
+	// execv(usershell, argv);
+}
+#endif /* BRCM_CMS_BUILD */
+
 /* Runs a command with "sh -c". Will close FDs (except stdin/stdout/stderr) and
  * re-enabled SIGPIPE. If cmd is NULL, will run a login shell.
  */
diff -Naur orig_dropbear-2022.83/dbutil.h dropbear-2022.83/dbutil.h
--- orig_dropbear-2022.83/dbutil.h	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/dbutil.h	2022-11-16 16:27:57.320963708 +0800
@@ -36,6 +36,9 @@
 void startsyslog(const char *ident);
 #endif
 
+// BRCM
+extern void *msgHandle;
+
 extern void (*_dropbear_exit)(int exitcode, const char* format, va_list param) ATTRIB_NORETURN;
 extern void (*_dropbear_log)(int priority, const char* format, va_list param);
 
@@ -63,6 +66,9 @@
 int spawn_command(void(*exec_fn)(const void *user_data), const void *exec_data,
 		int *writefd, int *readfd, int *errfd, pid_t *pid);
 void run_shell_command(const char* cmd, unsigned int maxfd, char* usershell);
+#ifdef BRCM_CMS_BUILD
+void bcm_run_shell_command(const char* cmd, unsigned int maxfd, char* usershell);
+#endif /* BRCM_CMS_BUILD */
 #if ENABLE_CONNECT_UNIX
 int connect_unix(const char* addr);
 #endif
diff -Naur orig_dropbear-2022.83/netio.c dropbear-2022.83/netio.c
--- orig_dropbear-2022.83/netio.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/netio.c	2022-11-16 16:27:57.320963708 +0800
@@ -5,6 +5,12 @@
 #include "debug.h"
 #include "runopts.h"
 
+// BRCM begin
+/* this file does not need the BASE64 define, but CMS needs it as a TR98 type. */
+#undef BASE64
+#include "cms.h"
+// BRCM end
+
 struct dropbear_progress_connection {
 	struct addrinfo *res;
 	struct addrinfo *res_iter;
diff -Naur orig_dropbear-2022.83/session.h dropbear-2022.83/session.h
--- orig_dropbear-2022.83/session.h	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/session.h	2022-11-16 16:27:57.320963708 +0800
@@ -341,6 +341,10 @@
 /* Global structs storing the state */
 extern struct sshsession ses;
 
+#ifdef DESKTOP_LINUX
+extern struct passwd fake_passwd;
+#endif
+
 #if DROPBEAR_SERVER
 extern struct serversession svr_ses;
 #endif /* DROPBEAR_SERVER */
diff -Naur orig_dropbear-2022.83/sshpty.c dropbear-2022.83/sshpty.c
--- orig_dropbear-2022.83/sshpty.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/sshpty.c	2022-11-16 16:27:57.320963708 +0800
@@ -27,6 +27,10 @@
 #undef HAVE_DEV_PTMX
 #endif
 
+#ifdef DESKTOP_LINUX
+#define USE_DEV_PTMX 1
+#endif
+
 #ifdef HAVE_PTY_H
 # include <pty.h>
 #endif
diff -Naur orig_dropbear-2022.83/svr-auth.c dropbear-2022.83/svr-auth.c
--- orig_dropbear-2022.83/svr-auth.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/svr-auth.c	2022-11-16 16:27:57.320963708 +0800
@@ -61,7 +61,7 @@
 
 	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_BANNER);
 	buf_putbufstring(ses.writepayload, banner);
-	buf_putstring(ses.writepayload, "en", 2);
+	buf_putstring(ses.writepayload, (unsigned char *)"en", 2);
 
 	encrypt_packet();
 
@@ -100,7 +100,7 @@
 
 	/* only handle 'ssh-connection' currently */
 	if (servicelen != SSH_SERVICE_CONNECTION_LEN
-			&& (strncmp(servicename, SSH_SERVICE_CONNECTION,
+			&& (strncmp((char *)servicename, SSH_SERVICE_CONNECTION,
 					SSH_SERVICE_CONNECTION_LEN) != 0)) {
 		
 		/* TODO - disconnect here */
@@ -249,7 +249,7 @@
 		ses.authstate.username = m_strdup(username);
 	} else {
 		/* check username hasn't changed */
-		if (strcmp(username, ses.authstate.username) != 0) {
+		if (strcmp((char *)username, ses.authstate.username) != 0) {
 			dropbear_exit("Client trying multiple usernames");
 		}
 	}
@@ -270,6 +270,7 @@
 		return DROPBEAR_FAILURE;
 	}
 
+#ifndef DESKTOP_LINUX
 	/* check if we are running as non-root, and login user is different from the server */
 	uid = geteuid();
 	if (!(DROPBEAR_SVR_MULTIUSER && uid == 0) && uid != ses.authstate.pw_uid) {
@@ -280,7 +281,7 @@
 		ses.authstate.checkusername_failed = 1;
 		return DROPBEAR_FAILURE;
 	}
-
+#endif
 	/* check for non-root if desired */
 	if (svr_opts.norootlogin && ses.authstate.pw_uid == 0) {
 		TRACE(("leave checkusername: root login disabled"))
diff -Naur orig_dropbear-2022.83/svr-authpasswd.c dropbear-2022.83/svr-authpasswd.c
--- orig_dropbear-2022.83/svr-authpasswd.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/svr-authpasswd.c	2022-11-16 16:29:44.315445460 +0800
@@ -29,8 +29,25 @@
 #include "buffer.h"
 #include "dbutil.h"
 #include "auth.h"
-#include "runopts.h"
 
+// BRCM begin
+#ifndef SSHD_GENKEY
+#ifdef BRCM_CMS_BUILD
+#undef BASE64
+#include "cms.h"
+#include "cms_cli.h"
+#include "cms_dal.h"
+#include "cms_seclog.h"
+#include "cms_log.h"
+extern int   glbAccessMode;
+extern UINT8 currPerm;
+extern char  curIpAddr[64];
+extern void *msgHandle;
+extern CmsEntityId myEid;
+extern SINT32 shmId;
+#endif
+#endif
+// BRCM end
 #if DROPBEAR_SVR_PASSWORD_AUTH
 
 /* not constant time when strings are differing lengths. 
@@ -50,10 +67,19 @@ static int constant_time_strcmp(const ch
  * appropriate */
 void svr_auth_password(int valid_user) {
 	
+//brcm begin
+#ifndef SSHD_GENKEY
 	char * passwdcrypt = NULL; /* the crypt from /etc/passwd or /etc/shadow */
 	char * testcrypt = NULL; /* crypt generated from the user's password sent */
 	char * password = NULL;
 	unsigned int passwordlen;
+#ifdef BRCM_CMS_BUILD
+	CmsSecurityLogData logData = { 0 };
+
+	// brcm add matched flag.
+	int matched = 0;
+	CmsRet ret = CMSRET_SUCCESS;
+#endif
 	unsigned int changepw;
 
 	/* check if client wants to change password */
@@ -70,6 +96,33 @@ void svr_auth_password(int valid_user) {
 		passwdcrypt = ses.authstate.pw_passwd;
 		testcrypt = crypt(password, passwdcrypt);
 	}
+
+#ifdef BRCM_CMS_BUILD
+        // brcm add local/remote login check
+        // We are doing all this auth checking inside sshd code instead of via proper CLI API.
+        if ((glbAccessMode == NETWORK_ACCESS_LAN_SIDE && \
+            (!strcmp(ses.authstate.username, "user") || !strcmp(ses.authstate.username, "admin"))) ||
+            (glbAccessMode == NETWORK_ACCESS_WAN_SIDE && !strcmp(ses.authstate.username, "support")))
+        {
+            matched = 1;
+
+            /* update cli lib with the application data */
+            cmsCli_setAppData("SSHD", NULL, ses.authstate.username, SSHD_PORT);
+
+            if (!strcmp(ses.authstate.username, "admin"))
+            {
+                currPerm = 0x80; /*PERM_ADMIN */
+            }
+            else if (!strcmp(ses.authstate.username, "support"))
+            {
+                currPerm = 0x40; /* PERM_SUPPORT */
+            }
+            else if (!strcmp(ses.authstate.username, "user"))
+            {
+                currPerm = 0x01;  /* PERM_USER */
+            }
+        }
+
 	m_burn(password, passwordlen);
 	m_free(password);
 
@@ -105,30 +158,53 @@ void svr_auth_password(int valid_user) {
 		return;
 	}
 
-	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
-		if (svr_opts.multiauthmethod && (ses.authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
-			/* successful password authentication, but extra auth required */
-			dropbear_log(LOG_NOTICE,
-					"Password auth succeeded for '%s' from %s, extra auth required",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
-			ses.authstate.authtypes &= ~AUTH_TYPE_PASSWORD; /* password auth ok, delete the method flag */
-			send_msg_userauth_failure(1, 0);  /* Send partial success */
-		} else {
-			/* successful authentication */
-			dropbear_log(LOG_NOTICE, 
-					"Password auth succeeded for '%s' from %s",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
-			send_msg_userauth_success();
-		}
+	CMSLOG_SEC_SET_PORT(&logData, SSHD_PORT);
+	CMSLOG_SEC_SET_APP_NAME(&logData, "SSHD");
+	CMSLOG_SEC_SET_USER(&logData, ses.authstate.username);
+	CMSLOG_SEC_SET_SRC_IP(&logData, &curIpAddr[0]);
+
+	 /*
+	 * Initialize our message link back to smd.
+	 */
+	cmsMsg_initWithFlags(myEid, EIF_MULTIPLE_INSTANCES, &msgHandle);
+
+	/*
+	 * Initialize MDM. The underlying CLI needs it.
+	 */
+	if ((ret = cmsMdm_initWithAcc(myEid, NDA_ACCESS_SSHD, msgHandle, &shmId)) != CMSRET_SUCCESS)
+	{
+		cmsLog_error("Could not initialize MDM, ret=%d", ret);
+		exit(-1);
+	}
+
+	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0 && matched) {
+		/* successful authentication */
+   // brcm commented next msg
+		//dropbear_log(LOG_NOTICE, 
+		//		"Password auth succeeded for '%s' from %s",
+		//		ses.authstate.pw_name,
+		//		svr_ses.addrstring);
+		send_msg_userauth_success();
+		cmsLog_security(LOG_SECURITY_AUTH_LOGIN_PASS, &logData, NULL);
 	} else {
-		dropbear_log(LOG_WARNING,
-				"Bad password attempt for '%s' from %s",
-				ses.authstate.pw_name,
-				svr_ses.addrstring);
-		send_msg_userauth_failure(0, 1);
+#ifdef DESKTOP_LINUX
+		dropbear_log(LOG_WARNING, "skip password auth for now, return success");
+		send_msg_userauth_success();
+#else
+//		dropbear_log(LOG_WARNING,
+//				"Bad password attempt for '%s' from %s",
+//				ses.authstate.pw_name,
+//				svr_ses.addrstring);
+//		send_msg_userauth_failure(0, 1);
+#endif
+		cmsLog_security(LOG_SECURITY_AUTH_LOGIN_FAIL, &logData, NULL);
 	}
+
+	/* clean up */
+	cmsMdm_cleanup();
+	cmsMsg_cleanup(&msgHandle);
+#endif /* BRCM_CMS_BUILD */
+#endif // brcm end, ifndef SSHD_GENKEY
 }
 
 #endif
diff -Naur orig_dropbear-2022.83/svr-chansession.c dropbear-2022.83/svr-chansession.c
--- orig_dropbear-2022.83/svr-chansession.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/svr-chansession.c	2022-11-16 16:27:57.320963708 +0800
@@ -38,6 +38,21 @@
 #include "runopts.h"
 #include "auth.h"
 
+// BRCM begin
+#ifndef SSHD_GENKEY
+#ifdef BRCM_CMS_BUILD
+#undef BASE64
+#include "cms.h"
+#include "cms_cli.h"
+#include "cms_msg.h"
+#include "cms_log.h"
+extern void *msgHandle;
+extern CmsEntityId myEid;
+extern SINT32 shmId;
+#endif
+#endif
+// BRCM end
+
 /* Handles sessions (either shells or programs) requested by the client */
 
 static int sessioncommand(struct Channel *channel, struct ChanSess *chansess,
@@ -48,6 +63,9 @@
 static int ptycommand(struct Channel *channel, struct ChanSess *chansess);
 static int sessionwinchange(const struct ChanSess *chansess);
 static void execchild(const void *user_data_chansess);
+#ifdef BRCM_CMS_BUILD
+static void bcm_execchild(const void *user_data_chansess);
+#endif /* BRCM_CMS_BUILD */
 static void addchildpid(struct ChanSess *chansess, pid_t pid);
 static void sesssigchild_handler(int val);
 static void closechansess(const struct Channel *channel);
@@ -191,7 +209,7 @@
 
 	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_REQUEST);
 	buf_putint(ses.writepayload, channel->remotechan);
-	buf_putstring(ses.writepayload, "exit-status", 11);
+	buf_putstring(ses.writepayload, (unsigned char *)"exit-status", 11);
 	buf_putbyte(ses.writepayload, 0); /* boolean FALSE */
 	buf_putint(ses.writepayload, chansess->exit.exitstatus);
 
@@ -227,12 +245,12 @@
 
 	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_REQUEST);
 	buf_putint(ses.writepayload, channel->remotechan);
-	buf_putstring(ses.writepayload, "exit-signal", 11);
+	buf_putstring(ses.writepayload, (unsigned char *)"exit-signal", 11);
 	buf_putbyte(ses.writepayload, 0); /* boolean FALSE */
-	buf_putstring(ses.writepayload, signame, strlen(signame));
+	buf_putstring(ses.writepayload, (unsigned char *)signame, strlen(signame));
 	buf_putbyte(ses.writepayload, chansess->exit.exitcore);
-	buf_putstring(ses.writepayload, "", 0); /* error msg */
-	buf_putstring(ses.writepayload, "", 0); /* lang */
+	buf_putstring(ses.writepayload, (unsigned char *)"", 0); /* error msg */
+	buf_putstring(ses.writepayload, (unsigned char *)"", 0); /* lang */
 
 	encrypt_packet();
 }
@@ -331,8 +349,8 @@
 		li = chansess_login_alloc(chansess);
 		login_logout(li);
 		login_free_entry(li);
-
-		pty_release(chansess->tty);
+//BRCM commented next line
+//		pty_release(chansess->tty);
 		m_free(chansess->tty);
 	}
 
@@ -384,25 +402,25 @@
 	dropbear_assert(chansess != NULL);
 	TRACE(("type is %s", type))
 
-	if (strcmp(type, "window-change") == 0) {
+        if (strcmp((char *)type, "window-change") == 0) {
 		ret = sessionwinchange(chansess);
-	} else if (strcmp(type, "shell") == 0) {
+	} else if (strcmp((char *)type, "shell") == 0) {
 		ret = sessioncommand(channel, chansess, 0, 0);
-	} else if (strcmp(type, "pty-req") == 0) {
+	} else if (strcmp((char *)type, "pty-req") == 0) {
 		ret = sessionpty(chansess);
-	} else if (strcmp(type, "exec") == 0) {
+	} else if (strcmp((char *)type, "exec") == 0) {
 		ret = sessioncommand(channel, chansess, 1, 0);
-	} else if (strcmp(type, "subsystem") == 0) {
+	} else if (strcmp((char *)type, "subsystem") == 0) {
 		ret = sessioncommand(channel, chansess, 1, 1);
 #if DROPBEAR_X11FWD
-	} else if (strcmp(type, "x11-req") == 0) {
+	} else if (strcmp((char *)type, "x11-req") == 0) {
 		ret = x11req(chansess);
 #endif
 #if DROPBEAR_SVR_AGENTFWD
-	} else if (strcmp(type, "auth-agent-req@openssh.com") == 0) {
+	} else if (strcmp((char *)type, "auth-agent-req@openssh.com") == 0) {
 		ret = svr_agentreq(chansess);
 #endif
-	} else if (strcmp(type, "signal") == 0) {
+	} else if (strcmp((char *)type, "signal") == 0) {
 		ret = sessionsignal(chansess);
 	} else {
 		/* etc, todo "env", "subsystem" */
@@ -440,7 +458,7 @@
 	signame = buf_getstring(ses.payload, NULL);
 
 	for (i = 0; signames[i].name != NULL; i++) {
-		if (strcmp(signames[i].name, signame) == 0) {
+		if (strcmp(signames[i].name, (char *)signame) == 0) {
 			sig = signames[i].signal;
 			break;
 		}
@@ -601,20 +619,23 @@
 	if (chansess->master != -1) {
 		dropbear_exit("Multiple pty requests");
 	}
-	if (pty_allocate(&chansess->master, &chansess->slave, namebuf, 64) == 0) {
+	if (pty_allocate(&chansess->master, &chansess->slave, (char *)namebuf, 64) == 0) {
 		TRACE(("leave sessionpty: failed to allocate pty"))
 		return DROPBEAR_FAILURE;
 	}
 	
-	chansess->tty = m_strdup(namebuf);
+	chansess->tty = (unsigned char*)m_strdup((char *)namebuf);
 	if (!chansess->tty) {
 		dropbear_exit("Out of memory"); /* TODO disconnect */
 	}
-
+#ifdef DESKTOP_LINUX
+	pw = &fake_passwd;
+#else
 	pw = getpwnam(ses.authstate.pw_name);
+#endif
 	if (!pw)
 		dropbear_exit("getpwnam failed after succeeding previously");
-	pty_setowner(pw, chansess->tty);
+	pty_setowner(pw, (char *)chansess->tty);
 
 	/* Set up the rows/col counts */
 	sessionwinchange(chansess);
@@ -684,7 +705,7 @@
 		}
 		if (issubsys) {
 #if DROPBEAR_SFTPSERVER
-			if ((cmdlen == 4) && strncmp(chansess->cmd, "sftp", 4) == 0) {
+			if ((cmdlen == 4) && strncmp((char *)chansess->cmd, "sftp", 4) == 0) {
 				char *expand_path = expand_homedir_path(SFTPSERVER_PATH);
 				m_free(chansess->cmd);
 				chansess->cmd = m_strdup(expand_path);
@@ -761,9 +782,15 @@
 	int ret;
 
 	TRACE(("enter noptycommand"))
+#ifdef BRCM_CMS_BUILD
+	ret = spawn_command(bcm_execchild, chansess, 
+			&channel->writefd, &channel->readfd, &channel->errfd,
+			&chansess->pid);
+#else
 	ret = spawn_command(execchild, chansess, 
 			&channel->writefd, &channel->readfd, &channel->errfd,
 			&chansess->pid);
+#endif
 
 	if (ret == DROPBEAR_FAILURE) {
 		return ret;
@@ -838,7 +865,7 @@
 		/* redirect stdin/stdout/stderr */
 		close(chansess->master);
 
-		pty_make_controlling_tty(&chansess->slave, chansess->tty);
+		pty_make_controlling_tty(&chansess->slave, (char *)chansess->tty);
 		
 		if ((dup2(chansess->slave, STDIN_FILENO) < 0) ||
 			(dup2(chansess->slave, STDOUT_FILENO) < 0)) {
@@ -846,13 +873,14 @@
 			return DROPBEAR_FAILURE;
 			}
 
+#ifndef DESKTOP_LINUX
 		/* write the utmp/wtmp login record - must be after changing the
 		 * terminal used for stdout with the dup2 above, otherwise
 		 * the wtmp login will not be recorded */
 		li = chansess_login_alloc(chansess);
 		login_login(li);
 		login_free_entry(li);
-
+#endif
 		/* Can now dup2 stderr. Messages from login_login() have gone
 		to the parent stderr */
 		if (dup2(chansess->slave, STDERR_FILENO) < 0) {
@@ -894,7 +922,11 @@
 		}
 #endif /* DO_MOTD */
 
+#ifdef BRCM_CMS_BUILD
+		bcm_execchild(chansess);
+#else
 		execchild(chansess);
+#endif
 		/* not reached */
 
 	} else {
@@ -943,6 +975,148 @@
 
 }
 
+#ifdef BRCM_CMS_BUILD
+/* Clean up, drop to user privileges, set up the environment and execute
+ * the command/shell. This function does not return. */
+static void bcm_execchild(const void *user_data) {
+// BRCM begin
+#ifndef SSHD_GENKEY
+	const struct ChanSess *chansess = user_data;
+	char *usershell = NULL;
+	CmsRet ret = CMSRET_SUCCESS;
+
+	/* with uClinux we'll have vfork()ed, so don't want to overwrite the
+	 * hostkey. can't think of a workaround to clear it */
+#if !DROPBEAR_VFORK
+	/* wipe the hostkey */
+	sign_key_free(svr_opts.hostkey);
+	svr_opts.hostkey = NULL;
+
+	/* overwrite the prng state */
+	seedrandom();
+#endif
+
+	/* clear environment */
+	/* if we're debugging using valgrind etc, we need to keep the LD_PRELOAD
+	 * etc. This is hazardous, so should only be used for debugging. */
+#ifndef DEBUG_VALGRIND
+#ifdef HAVE_CLEARENV
+/* BRCM:  we need the environ for our apps and LD_LIBRARY_PATH set in \etc\profile so comment the follwoing line
+     which clears the environment
+	clearenv();
+*/  
+#else /* don't HAVE_CLEARENV */
+	/* Yay for posix. */
+	if (environ) {
+		environ[0] = NULL;
+	}
+#endif /* HAVE_CLEARENV */
+#endif /* DEBUG_VALGRIND */
+
+#ifndef DESKTOP_LINUX
+#if DROPBEAR_SVR_MULTIUSER
+	/* We can only change uid/gid as root ... */
+	if (getuid() == 0) {
+
+		if ((setgid(ses.authstate.pw_gid) < 0) ||
+			(initgroups(ses.authstate.pw_name, 
+						ses.authstate.pw_gid) < 0)) {
+			dropbear_exit("Error changing user group");
+		}
+		if (setuid(ses.authstate.pw_uid) < 0) {
+			dropbear_exit("Error changing user");
+		}
+	} else {
+		/* ... but if the daemon is the same uid as the requested uid, we don't
+		 * need to */
+
+		/* XXX - there is a minor issue here, in that if there are multiple
+		 * usernames with the same uid, but differing groups, then the
+		 * differing groups won't be set (as with initgroups()). The solution
+		 * is for the sysadmin not to give out the UID twice */
+		if (getuid() != ses.authstate.pw_uid) {
+			dropbear_exit("Couldn't	change user as non-root");
+		}
+	}
+#endif
+
+	/* set env vars */
+	addnewvar("USER", ses.authstate.pw_name);
+	addnewvar("LOGNAME", ses.authstate.pw_name);
+	addnewvar("HOME", ses.authstate.pw_dir);
+	addnewvar("SHELL", get_user_shell());
+	// BRCM addnewvar("PATH", DEFAULT_PATH);
+	if (chansess->term != NULL) {
+		addnewvar("TERM", (char *)chansess->term);
+	}
+
+	if (chansess->tty) {
+		addnewvar("SSH_TTY", chansess->tty);
+	}
+	
+	if (chansess->connection_string) {
+		addnewvar("SSH_CONNECTION", chansess->connection_string);
+	}
+
+	if (chansess->client_string) {
+		addnewvar("SSH_CLIENT", chansess->client_string);
+	}
+	
+	if (chansess->original_command) {
+		addnewvar("SSH_ORIGINAL_COMMAND", chansess->original_command);
+	}
+
+	/* change directory */
+	if (chdir(ses.authstate.pw_dir) < 0) {
+		dropbear_exit("Error changing directory");
+	}
+
+#if DROPBEAR_X11FWD
+	/* set up X11 forwarding if enabled */
+	x11setauth(chansess);
+#endif
+#if DROPBEAR_SVR_AGENTFWD
+	/* set up agent env variable */
+	svr_agentset(chansess);
+#endif
+
+	usershell = m_strdup(get_user_shell());
+	bcm_run_shell_command(chansess->cmd, ses.maxfd, usershell);
+#endif /* ifndef DESKTOP_LINUX */
+
+	// BRCM begin: 
+	signal(SIGCHLD, SIG_DFL);
+
+	/*
+	 * Initialize our message link back to smd.
+	 */
+	cmsMsg_initWithFlags(myEid, EIF_MULTIPLE_INSTANCES, &msgHandle);
+
+	/*
+	 * Initialize MDM. The underlying CLI needs it.
+	 */
+	if ((ret = cmsMdm_initWithAcc(myEid, NDA_ACCESS_SSHD, msgHandle, &shmId)) != CMSRET_SUCCESS)
+	{
+		cmsLog_error("Could not initialize MDM, ret=%d", ret);
+		exit(-1);
+	}
+
+	/* go into CLI here */
+	cmsCli_run(msgHandle, SSHD_EXIT_ON_IDLE_TIMEOUT);
+
+	/* clean up */
+	cmsMdm_cleanup();
+	cmsMsg_cleanup(&msgHandle);
+
+	exit(0);
+	// BRCM end
+	/* only reached on error */
+	dropbear_exit("Child failed");
+#endif // SSHD_GENKEY
+}
+#endif /* BRCM_CMS_BUILD */
+
+// execchild source
 /* Clean up, drop to user privileges, set up the environment and execute
  * the command/shell. This function does not return. */
 static void execchild(const void *user_data) {
diff -Naur orig_dropbear-2022.83/svr-main.c dropbear-2022.83/svr-main.c
--- orig_dropbear-2022.83/svr-main.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/svr-main.c	2022-11-16 16:29:06.483739318 +0800
@@ -31,99 +31,104 @@
 #include "dbrandom.h"
 #include "crypto_desc.h"
 
+// BRCM add next line
+#include <netinet/in.h>
+
+#ifdef BRCM_CMS_BUILD
+/* BASE64 is used only in libtomcrypt, but CMS also defines it as a type.
+ * undef it here to avoid conflict. todo: should rename BASE64 to TRxBASE64 in CMS*/
+#undef BASE64 
+#include "cms.h"
+#include "cms_params.h"
+#include "cms_util.h"
+#include "cms_core.h"
+#include "cms_dal.h"
+#include "cms_cli.h"
+#include "cms_msg.h"
+
+//void *msgHandle=NULL;
+extern void *msgHandle;
+CmsEntityId myEid = EID_SSHD;
+SINT32 shmId=UNINITIALIZED_SHM_ID;
+
+#endif  /* BRCM_CMS_BUILD */
+
+char curIpAddr[64]; /* hold IPv4 or IPv6 address of current connection */
+
 static size_t listensockets(int *sock, size_t sockcount, int *maxfd);
 static void sigchld_handler(int dummy);
 static void sigsegv_handler(int);
 static void sigintterm_handler(int fish);
-static void main_inetd(void);
-static void main_noinetd(int argc, char ** argv, const char* multipath);
+
+// BRCM static void main_noinetd();
 static void commonsetup(void);
 
-#if defined(DBMULTI_dropbear) || !DROPBEAR_MULTI
-#if defined(DBMULTI_dropbear) && DROPBEAR_MULTI
-int dropbear_main(int argc, char ** argv, const char* multipath)
-#else
+
+
+#if 0
 int main(int argc, char ** argv)
-#endif
 {
-#if !DROPBEAR_MULTI
-	const char* multipath = NULL;
-#endif
-
 	_dropbear_exit = svr_dropbear_exit;
 	_dropbear_log = svr_dropbear_log;
 
-	disallow_core();
-
-	if (argc < 1) {
-		dropbear_exit("Bad argc");
-	}
-
 	/* get commandline options */
 	svr_getopts(argc, argv);
 
-#if INETD_MODE
-	/* service program mode */
-	if (svr_opts.inetdmode) {
-		main_inetd();
-		/* notreached */
-	}
-#endif
-
-#if DROPBEAR_DO_REEXEC
-	if (svr_opts.reexec_childpipe >= 0) {
-#ifdef PR_SET_NAME
-		/* Fix the "Name:" in /proc/pid/status, otherwise it's
-		a FD number from fexecve.
-		Failure doesn't really matter, it's mostly aesthetic */
-		prctl(PR_SET_NAME, basename(argv[0]), 0, 0);
-#endif
-		main_inetd();
-		/* notreached */
-	}
-#endif
-
-#if NON_INETD_MODE
-	main_noinetd(argc, argv, multipath);
+	main_noinetd();
 	/* notreached */
-#endif
 
 	dropbear_exit("Compiled without normal mode, can't run without -i\n");
 	return -1;
 }
 #endif
 
-#if INETD_MODE || DROPBEAR_DO_REEXEC
-static void main_inetd() {
-	char *host, *port = NULL;
+// BRCM begin
+int glbAccessMode;       /* global var to keep track of which side of the network we are accessed from */
+int dropbear_main(int argc, char ** argv, const char * multipath);
+ 
+	/* notreached */
+#ifdef BRCM_CMS_BUILD
+static void initLoggingFromConfig(UBOOL8 useConfiguredLogLevel)
+{
+	SshdCfgObject *obj;
+	InstanceIdStack iidStack = EMPTY_INSTANCE_ID_STACK;
+	CmsRet ret;
 
-	/* Set up handlers, syslog */
-	commonsetup();
+	if ((ret = cmsLck_acquireLockWithTimeout(CLI_BOOTUP_LOCK_TIMEOUT)) != CMSRET_SUCCESS)
+	{
+		cmsLog_error("failed to get lock, ret=%d", ret);
+		return;
+	}
+
+	if ((ret = cmsObj_get(MDMOID_SSHD_CFG, &iidStack, 0, (void **) &obj)) != CMSRET_SUCCESS)
+	{
+		cmsLog_error("get of SSHD_CFG object failed, ret=%d", ret);
+	}
+	else
+	{
+		if (useConfiguredLogLevel)
+		{
+			cmsLog_setLevel(cmsUtl_logLevelStringToEnum(obj->loggingLevel));
+		}
 
-	seedrandom();
+		cmsLog_setDestination(cmsUtl_logDestinationStringToEnum(obj->loggingDestination));
 
-	if (svr_opts.reexec_childpipe < 0) {
-		/* In case our inetd was lax in logging source addresses */
-		get_socket_address(0, NULL, NULL, &host, &port, 0);
-			dropbear_log(LOG_INFO, "Child connection from %s:%s", host, port);
-		m_free(host);
-		m_free(port);
-
-		/* Don't check the return value - it may just fail since inetd has
-		 * already done setsid() after forking (xinetd on Darwin appears to do
-		 * this */
-		setsid();
+		cmsObj_free((void **) &obj);
 	}
 
-	/* -1 for childpipe in the inetd case is discarded */
-	svr_session(0, svr_opts.reexec_childpipe);
+	cmsLck_releaseLock();
 
-	/* notreached */
 }
-#endif /* INETD_MODE */
+#endif /* BRCM_CMD_BUILD */
+
+
+#ifdef BRCM_CMS_BUILD
+int main(int argc, char **argv) {
+#else
+//void dropbear_main(void) {
+void main(void) {
+#endif
 
-#if NON_INETD_MODE
-static void main_noinetd(int argc, char ** argv, const char* multipath) {
 	fd_set fds;
 	unsigned int i, j;
 	int val;
@@ -131,7 +136,6 @@
 	int listensocks[MAX_LISTEN_ADDR];
 	size_t listensockcount = 0;
 	FILE *pidfile = NULL;
-	int execfd = -1;
 
 	int childpipes[MAX_UNAUTH_CLIENTS];
 	char * preauth_addrs[MAX_UNAUTH_CLIENTS];
@@ -139,9 +143,20 @@
 	int childsock;
 	int childpipe[2];
 
-	(void)argc;
-	(void)argv;
-	(void)multipath;
+#ifdef BRCM_CMS_BUILD
+	char connIfName[CMS_IFNAME_LENGTH]={0};
+	char remoteIpAddr[BUFLEN_64];  /* mwang_todo: should verify that sshd only supports one login at a time, otherwise, this global var will get overwritten */
+	char *pRemoteIpAddr;
+	CmsLogLevel logLevel=DEFAULT_LOG_LEVEL;
+	UBOOL8 useConfiguredLogLevel=TRUE;
+	SINT32 c, logLevelNum;
+	CmsRet ret;
+#endif
+
+	disallow_core();
+
+	/* get commandline options */
+	svr_getopts(argc, argv);
 
 	/* Note: commonsetup() must happen before we daemon()ise. Otherwise
 	   daemon() will chdir("/"), and we won't be able to find local-dir
@@ -154,6 +169,61 @@
 	}
 	memset(preauth_addrs, 0x0, sizeof(preauth_addrs));
 
+#ifdef BRCM_CMS_BUILD
+
+	cmsLog_initWithName(myEid, argv[0]);
+
+	while ((c = getopt(argc, argv, "v:m:")) != -1)
+	{
+		switch(c)
+		{
+			case 'm':
+				shmId = atoi(optarg);
+				break;
+
+			case 'v':
+				logLevelNum = atoi(optarg);
+				if (logLevelNum == 0)
+				{
+					logLevel = LOG_LEVEL_ERR;
+				}
+				else if (logLevelNum == 1)
+				{
+					logLevel = LOG_LEVEL_NOTICE;
+				}
+				else
+				{
+					logLevel = LOG_LEVEL_DEBUG;
+				}
+				cmsLog_setLevel(logLevel);
+				useConfiguredLogLevel = FALSE;
+				break;
+
+			default:
+				cmsLog_error("bad arguments, exit");
+				cmsLog_cleanup();
+				exit(-1);
+		}
+	}
+
+
+	/*
+	* Initialize our message link back to smd.
+	*/
+	cmsMsg_initWithFlags(myEid, EIF_MULTIPLE_INSTANCES, &msgHandle);
+
+	/*
+	* Initialize MDM.
+	*/
+	if ((ret = cmsMdm_initWithAcc(myEid, NDA_ACCESS_SSHD, msgHandle, &shmId)) != CMSRET_SUCCESS)
+	{
+		cmsLog_error("Could not initialize MDM, ret=%d", ret);
+		exit(-1);
+	}
+
+	initLoggingFromConfig(useConfiguredLogLevel);
+
+#endif	
 	/* Set up the listening sockets */
 	listensockcount = listensockets(listensocks, MAX_LISTEN_ADDR, &maxsock);
 	if (listensockcount == 0)
@@ -165,18 +235,8 @@
 		FD_SET(listensocks[i], &fds);
 	}
 
-#if DROPBEAR_DO_REEXEC
-	if (multipath) {
-		execfd = open(multipath, O_CLOEXEC|O_RDONLY);
-	} else {
-		execfd = open(argv[0], O_CLOEXEC|O_RDONLY);
-	}
-	if (execfd < 0) {
-		/* Just fallback to straight fork */
-		TRACE(("Couldn't open own binary %s, disabling re-exec: %s", argv[0], strerror(errno)))
-	}
-#endif
-
+// BRCM begin
+#if 0 
 	/* fork */
 	if (svr_opts.forkbg) {
 		int closefds = 0;
@@ -196,19 +256,23 @@
 	} else {
 		dropbear_log(LOG_INFO, "Not backgrounding");
 	}
+#endif
+// BRCM end
 
+#ifndef BRCM_CMS_BUILD
 	/* create a PID file so that we can be killed easily */
 	pidfile = fopen(svr_opts.pidfile, "w");
 	if (pidfile) {
 		fprintf(pidfile, "%d\n", getpid());
 		fclose(pidfile);
 	}
+#endif
 
 	/* incoming connection select loop */
 	for(;;) {
 
 		DROPBEAR_FD_ZERO(&fds);
-
+		
 		/* listening sockets */
 		for (i = 0; i < listensockcount; i++) {
 			FD_SET(listensocks[i], &fds);
@@ -226,9 +290,12 @@
 
 		if (ses.exitflag) {
 			unlink(svr_opts.pidfile);
+			cmsMdm_cleanup();
+			cmsMsg_cleanup(&msgHandle);
+			cmsLog_cleanup();
 			dropbear_exit("Terminated by signal");
 		}
-
+		
 		if (val == 0) {
 			/* timeout reached - shouldn't happen. eh */
 			continue;
@@ -265,14 +332,67 @@
 				continue;
 
 			remoteaddrlen = sizeof(remoteaddr);
-			childsock = accept(listensocks[i], 
-					(struct sockaddr*)&remoteaddr, &remoteaddrlen);
-
+			childsock = accept(listensocks[i], (struct sockaddr*)&remoteaddr, (socklen_t *)&remoteaddrlen);
 			if (childsock < 0) {
 				/* accept failed */
 				continue;
 			}
 
+         // Keven - begin
+#ifdef BRCM_CMS_BUILD
+#ifdef SUPPORT_IPV6
+         remoteIpAddr[0] = '\0';
+         inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)&remoteaddr)->sin6_addr), remoteIpAddr, sizeof(remoteIpAddr));
+
+         /* see if this is a IPv4-Mapped IPv6 address (::ffff:xxx.xxx.xxx.xxx) */
+         if (strchr(remoteIpAddr, '.') && strstr(remoteIpAddr, ":ffff:"))
+         {
+            /* IPv4 client */
+            
+            /* convert address to clean ipv4 address */
+            pRemoteIpAddr = strrchr(remoteIpAddr, ':') + 1;
+         }
+         else
+         {
+            /* IPv6 client */
+            pRemoteIpAddr = &remoteIpAddr[0];
+         }
+#else
+         strcpy(remoteIpAddr, inet_ntoa(((struct sockaddr_in *) &remoteaddr)->sin_addr));
+         pRemoteIpAddr = &remoteIpAddr[0];
+#endif /* SUPPORT_IPV6 */
+
+         if ((ret = cmsLck_acquireLockWithTimeout(CLI_BOOTUP_LOCK_TIMEOUT)) != CMSRET_SUCCESS)
+         {
+            cmsLog_error("failed to get lock, ret=%d", ret);
+            return -1;
+         }
+
+         cmsImg_saveIfNameFromSocket(childsock, connIfName);
+#ifndef DESKTOP_LINUX
+         if (cmsUtl_strstr(connIfName,"br0") == NULL)
+         {
+            glbAccessMode = NETWORK_ACCESS_WAN_SIDE;
+         }
+         else
+#endif /* DESKTOP_LINUX */
+         {
+            glbAccessMode = NETWORK_ACCESS_LAN_SIDE;
+         }
+
+         cmsLck_releaseLock();
+
+         /* update cli lib with the application data */
+         cmsCli_setAppData("SSHD", pRemoteIpAddr, NULL, SSHD_PORT);
+
+         memset(&curIpAddr[0], 0, sizeof(curIpAddr));
+         strncpy(&curIpAddr[0], pRemoteIpAddr, MIN(sizeof(curIpAddr), strlen(pRemoteIpAddr)));
+
+         cmsLog_debug("access from client ip=%s", pRemoteIpAddr);
+#endif /* BRCM_CMS_BUILD */
+
+         // Keven - end
+
 			/* Limit the number of unauthenticated connections per IP */
 			getaddrstring(&remoteaddr, &remote_host, NULL, 0);
 
@@ -313,7 +433,7 @@
 			}
 
 			addrandom((void*)&fork_ret, sizeof(fork_ret));
-
+			
 			if (fork_ret > 0) {
 
 				/* parent */
@@ -326,11 +446,13 @@
 
 				/* child */
 				getaddrstring(&remoteaddr, NULL, &remote_port, 0);
-				dropbear_log(LOG_INFO, "Child connection from %s:%s", remote_host, remote_port);
+				// BRCM
+				//dropbear_log(LOG_INFO, "Child connection from %s:%s", remote_host, remote_port);
+				
 				m_free(remote_host);
 				m_free(remote_port);
 
-#if !DEBUG_NOFORK
+#ifndef DEBUG_NOFORK
 				if (setsid() < 0) {
 					dropbear_exit("setsid: %s", strerror(errno));
 				}
@@ -343,44 +465,11 @@
 
 				m_close(childpipe[0]);
 
-				if (execfd >= 0) {
-#if DROPBEAR_DO_REEXEC
-					/* Add "-2 childpipe[1]" to the args and re-execute ourself. */
-					char **new_argv = m_malloc(sizeof(char*) * (argc+4));
-					char buf[10];
-					int pos0 = 0, new_argc = argc+2;
-
-					/* We need to specially handle "dropbearmulti dropbear". */
-					if (multipath) {
-						new_argv[0] = (char*)multipath;
-						pos0 = 1;
-						new_argc++;
-					}
-
-					memcpy(&new_argv[pos0], argv, sizeof(char*) * argc);
-					new_argv[new_argc-2] = "-2";
-					snprintf(buf, sizeof(buf), "%d", childpipe[1]);
-					new_argv[new_argc-1] = buf;
-					new_argv[new_argc] = NULL;
-
-					if ((dup2(childsock, STDIN_FILENO) < 0)) {
-						dropbear_exit("dup2 failed: %s", strerror(errno));
-					}
-					if (fcntl(childsock, F_SETFD, FD_CLOEXEC) < 0) {
-						TRACE(("cloexec for childsock %d failed: %s", childsock, strerror(errno)))
-					}
-					/* Re-execute ourself */
-					fexecve(execfd, new_argv, environ);
-					/* Not reached on success */
-
-					/* Fall back on plain fork otherwise.
-					 * To be removed in future once re-exec has been well tested */
-					dropbear_log(LOG_WARNING, "fexecve failed, disabling re-exec: %s", strerror(errno));
-					m_close(STDIN_FILENO);
-					m_free(new_argv);
-#endif /* DROPBEAR_DO_REEXEC */
-				}
-
+#ifdef BRCM_CMS_BUILD
+				/* clean up some initialized data that inherits from the parent */
+				cmsMdm_cleanup();
+				cmsMsg_cleanup(&msgHandle);
+#endif
 				/* start the session */
 				svr_session(childsock, childpipe[1]);
 				/* don't return */
@@ -398,7 +487,6 @@
 
 	/* don't reach here */
 }
-#endif /* NON_INETD_MODE */
 
 
 /* catch + reap zombie children */
diff -Naur orig_dropbear-2022.83/svr-runopts.c dropbear-2022.83/svr-runopts.c
--- orig_dropbear-2022.83/svr-runopts.c	2022-11-14 22:30:00.000000000 +0800
+++ dropbear-2022.83/svr-runopts.c	2022-11-16 16:27:57.324964100 +0800
@@ -152,7 +152,9 @@
 	svr_opts.bannerfile = NULL;
 	svr_opts.banner = NULL;
 	svr_opts.forced_command = NULL;
-	svr_opts.forkbg = 1;
+	// BRCM
+	svr_opts.forkbg = 0;
+
 	svr_opts.norootlogin = 0;
 #ifdef HAVE_GETGROUPLIST
 	svr_opts.restrict_group = NULL;
@@ -204,6 +206,7 @@
 #endif
 	opts.disable_ip_tos = 0;
 
+#ifndef BRCM_CMS_BUILD
 	for (i = 1; i < (unsigned int)argc; i++) {
 		if (argv[i][0] != '-' || argv[i][1] == '\0')
 			dropbear_exit("Invalid argument: %s", argv[i]);
@@ -364,6 +367,7 @@
 			}
 		}
 	}
+#endif
 
 	/* Set up listening ports */
 	if (svr_opts.portcount == 0) {
