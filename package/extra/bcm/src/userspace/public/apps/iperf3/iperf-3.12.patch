diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_api.c iperf-3.12/src/iperf_api.c
--- orig_iperf-3.12/src/iperf_api.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_api.c	2023-12-17 09:04:09.316605326 +0200
@@ -92,6 +92,10 @@
 #include "iperf_auth.h"
 #endif /* HAVE_SSL */
 
+#ifdef CONFIG_BCM_SPDTEST
+#include "spdt_api.h"
+#include "bcm_net.h"
+#endif
 /* Forwards. */
 static int send_parameters(struct iperf_test *test);
 static int get_parameters(struct iperf_test *test);
@@ -128,6 +132,26 @@ void warning(const char *str)
 
 /************** Getter routines for some fields inside iperf_test *************/
 
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+static int streams[] = { -1, -1, -1, -1 };
+void iperf_set_stream_socket(uint8_t hw_fd, int s)
+{
+    streams[hw_fd] = s;
+}
+
+int iperf_socket_to_stream(int s)
+{
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(streams); i++)
+    {
+        if (s == streams[i])
+            return i;
+    }
+
+    return s;
+}
+
 int
 iperf_get_verbose(struct iperf_test *ipt)
 {
@@ -832,7 +856,25 @@ set_protocol(struct iperf_test *test, in
 void
 iperf_on_new_stream(struct iperf_stream *sp)
 {
-    connect_msg(sp);
+#ifdef CONFIG_BCM_SPDTEST
+    if (sp->test->hwoffl && (sp->test->role != 's' || sp->test->protocol->id == Pudp))
+    {
+        /* Save connetion addresses in stream context */
+        int rc;
+        spdt_conn_params_t conn_addr;
+        uint8_t hw_fd = iperf_socket_to_stream(sp->socket);;
+
+        rc = spdt_get_conn_params(hw_fd, &conn_addr);
+        if (rc)
+        {
+            printf("HWOFFL:Failed to retreive connection addresses rc=%d\n", rc);
+        }
+
+        memcpy(&sp->remote_addr, &conn_addr.server_addr, sizeof(struct sockaddr_storage));
+        memcpy(&sp->local_addr, &conn_addr.local_addr, sizeof(struct sockaddr_storage));
+    }
+#endif 
+    connect_msg(sp);   
 }
 
 void
@@ -940,12 +982,141 @@ iperf_on_connect(struct iperf_test *test
     }
 }
 
+#ifdef CONFIG_BCM_SPDTEST
+void iperf_hw_disconnect_sock(struct iperf_test *test, int hw_fd)
+{
+    if (test->mode == SENDER)
+        spdt_send_stop(hw_fd);
+    else
+        spdt_recv_stop(hw_fd);
+
+    /* Finished test with TCP sender already disconnected.
+     * Disconnect socket in case of a signal received (done == 2) */
+    if (!(test->mode == SENDER && test->protocol->id == Ptcp && test->done == 1))
+        spdt_disconnect(hw_fd);
+}
+
+void iperf_hw_uninit(struct iperf_test *test)
+{
+    struct iperf_stream *sp;
+    SLIST_FOREACH(sp, &test->streams, streams) 
+    {
+        int hw_fd = iperf_socket_to_stream(sp->socket);
+        if (hw_fd > -1)
+        {
+            iperf_set_stream_socket(hw_fd, -1);
+            iperf_hw_disconnect_sock(test, hw_fd);
+            spdt_uninit(hw_fd);
+        }
+    } 
+}
+#endif
+
 void
 iperf_on_test_finish(struct iperf_test *test)
 {
+#ifdef CONFIG_BCM_SPDTEST
+    if (test->hwoffl && test->role != 's')
+        iperf_hw_uninit(test);
+#endif
 }
 
+#ifdef CONFIG_BCM_SPDTEST
+int
+iperf_set_hw_offload(struct iperf_test *test)
+{
+    struct protocol *tcp, *udp;
+    
+    /*replace the tcp callbacks */
+    tcp = get_protocol(test, Ptcp);
+    if (!tcp)
+    {
+        printf("Failed to update TCP to HW offload");
+        return -1;
+    }
+
+    if (test->role == 'c')
+    {
+        tcp->connect = iperf_tcp_hwoffl_connect;
+        tcp->recv = iperf_tcp_hwoffl_recv;
+        tcp->send = iperf_tcp_hwoffl_send;
+    }
+
+    udp = get_protocol(test, Pudp);
+    if (!udp)
+    {
+        printf("Failed to update UDP to HW offload");
+        return -1;
+    }
+
+    udp->connect = iperf_udp_hwoffl_connect;
+    udp->recv = iperf_udp_hwoffl_recv;
+    udp->send = iperf_udp_hwoffl_send;
+
+    printf("BROADCOM iPerf3 %s Offload Enabled\n", 
+        (HW_OFFLOAD_MODE == test->hwoffl ? "Hardware" : "Software") );
+
+    return 0;
+}
+
+void
+iperf_udp_detect_max_rate(struct iperf_test *test)
+{
+    struct addrinfo *result = NULL;
+    int rc = -1;
+    char dst_ip[INET6_ADDRSTRLEN] = {0};
+    char ifc_ip[INET6_ADDRSTRLEN] = {0};
+    char ifc_name[UNIT_LEN] = {0};
+    int max_kbps_us, max_kbps_ds, max_rate;
+    iperf_size_t ifc_max_rate, max_rate_per_stream;
+
+    if (test->server_hostname)
+        rc = getaddrinfo(test->server_hostname, NULL, NULL, &result);
+    else if (test->bind_address)
+        rc = getaddrinfo(test->bind_address, NULL, NULL, &result);
+    if (rc)
+        goto exit;
+
+    rc = getnameinfo(result->ai_addr, sizeof(struct sockaddr_storage), dst_ip, NI_MAXHOST, NULL, 0,
+        NI_NUMERICHOST);
+    if (rc)
+        goto exit;
+
+    rc = bcmNet_getRouteInfoToServer(dst_ip, ifc_name, ifc_ip, &max_kbps_us, &max_kbps_ds);
+    if (rc)
+        goto exit;
+
+    if (test->mode == SENDER)
+        max_rate = max_kbps_us;
+    else
+        max_rate = max_kbps_ds;
+
+    printf("Max detected rate <%d kbps>\n", max_rate);
+
+    ifc_max_rate = 1000.0 * max_rate;
+    max_rate_per_stream = ifc_max_rate / test->num_streams;
+
+    /* Total rate of all streams must not exceed the interface max rate limit */
+    if (!test->settings->rate || (test->settings->rate * test->num_streams > ifc_max_rate))
+        test->settings->rate = max_rate_per_stream;
+
+exit:
+    if (result)
+        freeaddrinfo(result);
+
+    if (rc)
+    {
+        if (!test->settings->rate)
+        {
+            /* Failed to detect the rate and bitrate was set to 0 - set default of 1G */
+            test->settings->rate = UDP_HW_RATE; 
+            warning("Getting interface max rate failed. Using UDP HW default rate\n");
+        }
+        warning("Getting interface max rate failed. Using recieved bitrate\n");
+    }
+}
 
+#endif
 /******************************************************************************/
 
 /*
@@ -1001,6 +1172,10 @@ iperf_parse_arguments(struct iperf_test
 {
     static struct option longopts[] =
     {
+#ifdef CONFIG_BCM_SPDTEST
+        {"hwoffl", optional_argument, NULL, 'H'},
+        {"legacy", no_argument, NULL, 'o'},
+#endif        
         {"port", required_argument, NULL, 'p'},
         {"format", required_argument, NULL, 'f'},
         {"interval", required_argument, NULL, 'i'},
@@ -1102,8 +1277,25 @@ iperf_parse_arguments(struct iperf_test
     char *client_username = NULL, *client_rsa_public_key = NULL, *server_rsa_private_key = NULL;
 #endif /* HAVE_SSL */
 
+    test->bind_address = NULL;
+    test->server_hostname = NULL;
+
+#ifdef CONFIG_BCM_SPDTEST
+    while ((flag = getopt_long(argc, argv, "p:f:i:HoD1VJvsc:ub:t:n:k:l:P:Rw:B:M:N46S:L:ZO:F:A:T:C:dI:hX:", longopts, NULL)) != -1) {
+        switch (flag) {
+            case 'H':
+                test->hwoffl = HW_OFFLOAD_MODE;
+                if (optarg && *optarg == 's') {
+                    test->hwoffl = SW_OFFLOAD_MODE;
+                }
+                break;
+            case 'o':
+                test->legacy = 1;
+                break;
+#else  
     while ((flag = getopt_long(argc, argv, "p:f:i:D1VJvsc:ub:t:n:k:l:P:Rw:B:M:N46S:L:ZO:F:A:T:C:dI:hX:", longopts, NULL)) != -1) {
         switch (flag) {
+#endif
             case 'p':
 		portno = atoi(optarg);
 		if (portno < 1 || portno > 65535) {
@@ -1577,6 +1769,19 @@ iperf_parse_arguments(struct iperf_test
         }
     }
 
+#ifdef CONFIG_BCM_SPDTEST
+    if (iperf_get_test_protocol_id(test) == Pudp && test->hwoffl == SW_OFFLOAD_MODE)
+    {
+        i_errno = IEUDPSOFTWARE;
+        return -1;
+    }
+
+    if (test->hwoffl)
+    {
+        iperf_set_hw_offload(test);
+    }
+#endif
+
     /* Check flag / role compatibility. */
     if (test->role == 'c' && server_flag) {
         i_errno = IESERVERONLY;
@@ -1652,12 +1857,23 @@ iperf_parse_arguments(struct iperf_test
 #endif //HAVE_SSL
     if (blksize == 0) {
 	if (test->protocol->id == Pudp)
+#ifdef CONFIG_BCM_SPDTEST
+    if (test->hwoffl)
+	    blksize = DEFAULT_HW_UDP_BLKSIZE;
+    else
+#endif
 	    blksize = 0;	/* try to dynamically determine from MSS */
 	else if (test->protocol->id == Psctp)
 	    blksize = DEFAULT_SCTP_BLKSIZE;
 	else
 	    blksize = DEFAULT_TCP_BLKSIZE;
     }
+#ifdef CONFIG_BCM_SPDTEST
+    if (test->hwoffl && test->protocol->id == Pudp && blksize < MIN_HW_UDP_BLKSIZE) {
+        i_errno = IEBLOCKSIZE;
+        return -1;
+    }
+#endif
     if ((test->protocol->id != Pudp && blksize <= 0)
 	|| blksize > MAX_BLOCKSIZE) {
 	i_errno = IEBLOCKSIZE;
@@ -1693,6 +1909,17 @@ iperf_parse_arguments(struct iperf_test
         // if failing to read file stat, it should fallback to default duration mode
     }
 
+#ifdef CONFIG_BCM_SPDTEST
+    if (test->hwoffl)
+    {
+        if (test->protocol->id == Pudp && rate_flag)
+        {
+            iperf_udp_detect_max_rate(test);
+            printf("Using rate <%lld bps>\n", test->settings->rate);
+        }
+    }
+#endif
+
     if ((test->settings->bytes != 0 || test->settings->blocks != 0) && ! duration_flag)
         test->duration = 0;
 
@@ -2669,7 +2896,11 @@ connect_msg(struct iperf_stream *sp)
     char ipl[INET6_ADDRSTRLEN], ipr[INET6_ADDRSTRLEN];
     int lport, rport;
 
+#ifdef CONFIG_BCM_SPDTEST
+    if (sp->remote_addr.ss_family == AF_INET) {            
+#else    
     if (getsockdomain(sp->socket) == AF_INET) {
+#endif
         inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->local_addr)->sin_addr, ipl, sizeof(ipl));
 	mapped_v4_to_regular_v4(ipl);
         inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->remote_addr)->sin_addr, ipr, sizeof(ipr));
@@ -3185,6 +3416,47 @@ iperf_stats_callback(struct iperf_test *
     temp.omitted = test->omitting;
     SLIST_FOREACH(sp, &test->streams, streams) {
         rp = sp->result;
+#ifdef CONFIG_BCM_SPDTEST
+        if (test->hwoffl && (test->role != 's' || test->protocol->id == Pudp))
+        {
+            /* In case of HW offload, need to fetch counters per stream */
+            spdt_stat_t spd_stat = {};
+            uint8_t hw_fd = iperf_socket_to_stream(sp->socket);;
+
+            spdt_stats_get(hw_fd, SPDT_STATS_GET_CURRENT, &spd_stat);
+            if (test->protocol->id == Ptcp)
+            {
+                tcp_spdt_rep_t *spd_report;
+                spd_report = &(spd_stat.proto_ext.tcp_speed_rep);
+
+                if (test->mode == SENDER) {
+                    rp->bytes_sent_this_interval = (iperf_size_t)spd_report->num_bytes - rp->bytes_sent;
+                    rp->bytes_sent = (iperf_size_t)spd_report->num_bytes;
+                } else {
+                    rp->bytes_received_this_interval = (iperf_size_t)spd_report->num_bytes - rp->bytes_received;
+                    rp->bytes_received = (iperf_size_t)spd_report->num_bytes;
+                }
+            }
+            else if (test->protocol->id == Pudp)
+            {
+                udp_spdt_iperf3_stat_t *spd_report;
+                spd_report = &(spd_stat.proto_ext.udp_iperf3);
+
+                if (test->mode == SENDER) {
+                    rp->bytes_sent_this_interval = (iperf_size_t)(spd_report->tx.bytes);
+                    rp->bytes_sent += rp->bytes_sent_this_interval;
+                    sp->packet_count += (int)(spd_report->tx.packets);
+                } else {
+                    rp->bytes_received_this_interval = (iperf_size_t)(spd_report->rx.bytes);
+                    rp->bytes_received += rp->bytes_received_this_interval;
+                    sp->packet_count += (int)(spd_report->rx.packets);
+                }
+                sp->cnt_error += (int)(spd_report->error_cnt_pkts); 
+                sp->outoforder_packets += (int)(spd_report->out_of_order_pkts);
+                sp->jitter = (double)(spd_report->jitter);
+            }
+        }
+#endif
 	temp.bytes_transferred = sp->sender ? rp->bytes_sent_this_interval : rp->bytes_received_this_interval;
 
         // Total bytes transferred this interval
@@ -3201,55 +3473,56 @@ iperf_stats_callback(struct iperf_test *
         memcpy(&temp.interval_end_time, &rp->end_time, sizeof(struct iperf_time));
         iperf_time_diff(&temp.interval_start_time, &temp.interval_end_time, &temp_time);
         temp.interval_duration = iperf_time_in_secs(&temp_time);
-	if (test->protocol->id == Ptcp) {
-	    if ( has_tcpinfo()) {
-		save_tcpinfo(sp, &temp);
-		if (test->sender_has_retransmits == 1) {
-		    long total_retrans = get_total_retransmits(&temp);
-		    temp.interval_retrans = total_retrans - rp->stream_prev_total_retrans;
-		    rp->stream_retrans += temp.interval_retrans;
-		    rp->stream_prev_total_retrans = total_retrans;
-
-		    temp.snd_cwnd = get_snd_cwnd(&temp);
-		    if (temp.snd_cwnd > rp->stream_max_snd_cwnd) {
-			rp->stream_max_snd_cwnd = temp.snd_cwnd;
-		    }
-
-		    temp.snd_wnd = get_snd_wnd(&temp);
-		    if (temp.snd_wnd > rp->stream_max_snd_wnd) {
-			rp->stream_max_snd_wnd = temp.snd_wnd;
-		    }
-
-		    temp.rtt = get_rtt(&temp);
-		    if (temp.rtt > rp->stream_max_rtt) {
-			rp->stream_max_rtt = temp.rtt;
-		    }
-		    if (rp->stream_min_rtt == 0 ||
-			temp.rtt < rp->stream_min_rtt) {
-			rp->stream_min_rtt = temp.rtt;
-		    }
-		    rp->stream_sum_rtt += temp.rtt;
-		    rp->stream_count_rtt++;
+        if (
+#ifdef CONFIG_BCM_SPDTEST
+            !test->hwoffl &&
+#endif
+            test->protocol->id == Ptcp ) {
+            if ( has_tcpinfo()) {
+                save_tcpinfo(sp, &temp);
+                if (test->mode == SENDER && test->sender_has_retransmits) {
+                    long total_retrans = get_total_retransmits(&temp);
+                    temp.interval_retrans = total_retrans - rp->stream_prev_total_retrans;
+                    rp->stream_retrans += temp.interval_retrans;
+                    rp->stream_prev_total_retrans = total_retrans;
+
+                    temp.snd_cwnd = get_snd_cwnd(&temp);
+                    if (temp.snd_cwnd > rp->stream_max_snd_cwnd) {
+                        rp->stream_max_snd_cwnd = temp.snd_cwnd;
+                    }
 
-		    temp.rttvar = get_rttvar(&temp);
-		    temp.pmtu = get_pmtu(&temp);
-		}
-	    }
-	} else {
-	    if (irp == NULL) {
-		temp.interval_packet_count = sp->packet_count;
-		temp.interval_outoforder_packets = sp->outoforder_packets;
-		temp.interval_cnt_error = sp->cnt_error;
-	    } else {
-		temp.interval_packet_count = sp->packet_count - irp->packet_count;
-		temp.interval_outoforder_packets = sp->outoforder_packets - irp->outoforder_packets;
-		temp.interval_cnt_error = sp->cnt_error - irp->cnt_error;
-	    }
-	    temp.packet_count = sp->packet_count;
-	    temp.jitter = sp->jitter;
-	    temp.outoforder_packets = sp->outoforder_packets;
-	    temp.cnt_error = sp->cnt_error;
-	}
+                    temp.rtt = get_rtt(&temp);
+                    if (temp.rtt > rp->stream_max_rtt) {
+                        rp->stream_max_rtt = temp.rtt;
+                    }
+                    if (rp->stream_min_rtt == 0 ||
+                        temp.rtt < rp->stream_min_rtt) {
+                        rp->stream_min_rtt = temp.rtt;
+                    }
+                    rp->stream_sum_rtt += temp.rtt;
+                    rp->stream_count_rtt++;
+                }
+            }
+        } else {
+            if (test->protocol->id == Ptcp && has_tcpinfo())
+            {
+                temp.snd_cwnd = 0;
+                temp.interval_retrans = 0;
+            }
+            if (irp == NULL) {
+                temp.interval_packet_count = sp->packet_count;
+                temp.interval_outoforder_packets = sp->outoforder_packets;
+                temp.interval_cnt_error = sp->cnt_error;
+            } else {
+                temp.interval_packet_count = sp->packet_count - irp->packet_count;
+                temp.interval_outoforder_packets = sp->outoforder_packets - irp->outoforder_packets;
+                temp.interval_cnt_error = sp->cnt_error - irp->cnt_error;
+            }
+            temp.packet_count = sp->packet_count;
+            temp.jitter = sp->jitter;
+            temp.outoforder_packets = sp->outoforder_packets;
+            temp.cnt_error = sp->cnt_error;
+        }
         add_to_interval_list(rp, &temp);
         rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;
     }
@@ -4273,6 +4546,10 @@ iperf_new_stream(struct iperf_test *test
     } else
         sp->diskfile_fd = -1;
 
+#ifdef CONFIG_BCM_SPDTEST
+    if (!test->hwoffl)
+    {
+#endif
     /* Initialize stream */
     if (test->repeating_payload)
         fill_with_repeating_pattern(sp->buffer, test->settings->blksize);
@@ -4286,6 +4563,9 @@ iperf_new_stream(struct iperf_test *test
         free(sp);
         return NULL;
     }
+#ifdef CONFIG_BCM_SPDTEST
+    }    
+#endif    
     iperf_add_stream(test, sp);
 
     return sp;
@@ -4516,7 +4796,7 @@ iperf_got_sigend(struct iperf_test *test
     if (test->role == 'c' ||
       (test->role == 's' && test->state == TEST_RUNNING)) {
 
-	test->done = 1;
+	test->done = 2; /* Indication of the exit by a signal */
 	cpu_util(test->cpu_util);
 	test->stats_callback(test);
 	test->state = DISPLAY_RESULTS; /* change local state only */
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_api.h iperf-3.12/src/iperf_api.h
--- orig_iperf-3.12/src/iperf_api.h	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_api.h	2023-12-17 09:04:09.316605326 +0200
@@ -53,7 +53,11 @@ typedef uint64_t iperf_size_t;
 #define Ptcp SOCK_STREAM
 #define Pudp SOCK_DGRAM
 #define Psctp 12
-#define DEFAULT_UDP_BLKSIZE 1460 /* default is dynamically set, else this */
+#define DEFAULT_UDP_BLKSIZE 1400 /* default is dynamically set, else this */
+#ifdef CONFIG_BCM_SPDTEST
+#define DEFAULT_HW_UDP_BLKSIZE 1400
+#define MIN_HW_UDP_BLKSIZE 32
+#endif
 #define DEFAULT_TCP_BLKSIZE (128 * 1024)  /* default read/write block size */
 #define DEFAULT_SCTP_BLKSIZE (64 * 1024)
 #define DEFAULT_PACING_TIMER 1000
@@ -390,6 +394,7 @@ enum {
     IERCVTIMEOUT = 31,      // Illegal message receive timeout
     IERVRSONLYRCVTIMEOUT = 32,  // Client receive timeout is valid only in reverse mode
     IESNDTIMEOUT = 33,      // Illegal message send timeout
+    IEUDPSOFTWARE = 34,     // No UDP driver mode
     /* Test errors */
     IENEWTEST = 100,        // Unable to create a new test (check perror)
     IEINITTEST = 101,       // Test initialization failed (check perror)
@@ -453,6 +458,7 @@ enum {
     /* Timer errors */
     IENEWTIMER = 300,       // Unable to create new timer (check perror)
     IEUPDATETIMER = 301,    // Unable to update timer (check perror)
+    IESETMARK = 302,    // Unable to set socket SO_MARK
 };
 
 
@@ -461,4 +467,11 @@ enum {
 #endif
 
 
+#ifdef CONFIG_BCM_SPDTEST
+void iperf_hw_disconnect_sock(struct iperf_test *test, int sock);
+void iperf_hw_uninit(struct iperf_test *test);
+int iperf_socket_to_stream(int s);
+void iperf_set_stream_socket(uint8_t hw_fd, int s);
+#endif
+
 #endif /* !__IPERF_API_H */
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_client_api.c iperf-3.12/src/iperf_client_api.c
--- orig_iperf-3.12/src/iperf_client_api.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_client_api.c	2023-12-17 09:05:05.000576482 +0200
@@ -51,6 +51,8 @@
 #endif /* TCP_CA_NAME_MAX */
 #endif /* HAVE_TCP_CONGESTION */
 
+#define SAFE_TCP_MSS 1448
+
 int
 iperf_create_streams(struct iperf_test *test, int sender)
 {
@@ -80,6 +82,22 @@ iperf_create_streams(struct iperf_test *
         if (s < 0)
             return -1;
 
+#ifdef CONFIG_BCM_SPDTEST
+        if (test->hwoffl)
+            goto hwoffl_bypass;
+#endif
+
+#ifdef HAVE_TCP_DISCARD
+        if((test->protocol->id == Ptcp) && test->zerocopy
+                && (test->mode == RECEIVER)) {
+            int opt=1;
+            if (setsockopt(s, IPPROTO_TCP, TCP_DISCARD, &opt, sizeof(opt)) < 0)
+                printf("Error: not able to set TCP_DISCARD \n");
+            else
+                printf("Configured TCP_DISCARD option \n");
+        }
+#endif
+
 #if defined(HAVE_TCP_CONGESTION)
 	if (test->protocol->id == Ptcp) {
 	    if (test->congestion) {
@@ -114,13 +132,19 @@ iperf_create_streams(struct iperf_test *
 	    }
 	}
 #endif /* HAVE_TCP_CONGESTION */
-
+#ifdef CONFIG_BCM_SPDTEST
+    if (!test->hwoffl) {
+#endif   
 	if (sender)
 	    FD_SET(s, &test->write_set);
 	else
 	    FD_SET(s, &test->read_set);
 	if (s > test->max_fd) test->max_fd = s;
 
+#ifdef CONFIG_BCM_SPDTEST
+    }
+hwoffl_bypass:
+#endif
         sp = iperf_new_stream(test, s, sender);
         if (!sp)
             return -1;
@@ -295,9 +319,18 @@ iperf_handle_message_client(struct iperf
             }
             else if (iperf_create_streams(test, test->mode) < 0)
                 return -1;
+            
+#if CONFIG_BCM_SPDTEST
+            if (test->hwoffl && test->legacy && test->mode != SENDER && iperf_init_test(test) < 0)
+                return -1;
+#endif
             break;
         case TEST_START:
+#if CONFIG_BCM_SPDTEST
+            if ((!test->legacy || !test->hwoffl || test->mode == SENDER) && iperf_init_test(test) < 0)
+#else
             if (iperf_init_test(test) < 0)
+#endif
                 return -1;
             if (create_client_timers(test) < 0)
                 return -1;
@@ -384,6 +417,15 @@ iperf_connect(struct iperf_test *test)
         return -1;
     }
 
+#ifdef CONFIG_BCM_SPDTEST
+    // Give control socket a high priority
+    uint32_t mark = 7;
+    if (test->hwoffl && setsockopt(test->ctrl_sck, SOL_SOCKET, SO_MARK, &mark, sizeof(mark))) {
+        i_errno = IESETMARK;
+        return -1;
+    }
+#endif
+
     // set TCP_NODELAY for lower latency on control messages
     int flag = 1;
     if (setsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, sizeof(int))) {
@@ -410,11 +452,12 @@ iperf_connect(struct iperf_test *test)
 
     len = sizeof(opt);
     if (getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len) < 0) {
-        test->ctrl_sck_mss = 0;
+        test->ctrl_sck_mss = test->settings->mss ?: SAFE_TCP_MSS;
     }
     else {
-        if (opt > 0 && opt <= MAX_UDP_BLOCKSIZE) {
+        if (opt > 0 && opt <= SAFE_TCP_MSS) {
             test->ctrl_sck_mss = opt;
+            // do not set mss, as server may have a lower limit
         }
         else {
             char str[WARN_STR_LEN];
@@ -423,11 +466,13 @@ iperf_connect(struct iperf_test *test)
             warning(str);
 
             test->ctrl_sck_mss = 0;
+            test->settings->mss = test->settings->mss ?: SAFE_TCP_MSS;
         }
     }
 
     if (test->verbose) {
 	printf("Control connection MSS %d\n", test->ctrl_sck_mss);
+        printf("Data connection MSS %d\n", test->settings->mss);
     }
 
     /*
@@ -483,12 +528,15 @@ iperf_client_end(struct iperf_test *test
         iperf_err(NULL, "No test\n");
         return -1;
     }
+
+#ifndef CONFIG_BCM_SPDTEST    
     struct iperf_stream *sp;
 
     /* Close all stream sockets */
     SLIST_FOREACH(sp, &test->streams, streams) {
         close(sp->socket);
     }
+#endif
 
     /* show final summary */
     test->reporter_callback(test);
@@ -535,11 +583,11 @@ iperf_run_client(struct iperf_test * tes
 
     if (test->affinity != -1)
 	if (iperf_setaffinity(test, test->affinity) != 0)
-	    return -1;
+            goto exit;
 
     if (test->json_output)
 	if (iperf_json_start(test) < 0)
-	    return -1;
+            goto exit;
 
     if (test->json_output) {
 	cJSON_AddItemToObject(test->json_start, "version", cJSON_CreateString(version));
@@ -676,6 +724,19 @@ iperf_run_client(struct iperf_test * tes
 		test->done = 1;
 		cpu_util(test->cpu_util);
 		test->stats_callback(test);
+#ifdef CONFIG_BCM_SPDTEST
+                if (test->mode == SENDER && test->hwoffl)
+                {
+                    struct iperf_stream *sp;
+
+                    /* WAR: It's possible that the stream will cause the termination packet to be lost.
+                     * Hence, first stop the stream and then send the TEST_END */
+                    SLIST_FOREACH(sp, &test->streams, streams) 
+                    {
+                        test->protocol->id == Pudp ? spdt_send_stop(sp->socket) : spdt_disconnect(sp->socket);
+                    } 
+                }
+#endif
 		if (iperf_set_send_state(test, TEST_END) != 0)
                     goto cleanup_and_fail;
 	    }
@@ -693,7 +754,7 @@ iperf_run_client(struct iperf_test * tes
 
     if (test->json_output) {
 	if (iperf_json_finish(test) < 0)
-	    return -1;
+	    goto exit;
     } else {
 	iperf_printf(test, "\n");
 	iperf_printf(test, "%s", report_done);
@@ -714,5 +775,11 @@ iperf_run_client(struct iperf_test * tes
         return 0;
     }
     iflush(test);
+
+exit:
+#ifdef CONFIG_BCM_SPDTEST
+    if (test->hwoffl)
+        iperf_hw_uninit(test);
+#endif
     return -1;
 }
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_error.c iperf-3.12/src/iperf_error.c
--- orig_iperf-3.12/src/iperf_error.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_error.c	2023-12-17 09:04:09.316605326 +0200
@@ -153,7 +153,12 @@ iperf_strerror(int int_errno)
             snprintf(errstr, len, "number of parallel streams too large (maximum = %d)", MAX_STREAMS);
             break;
         case IEBLOCKSIZE:
+#ifdef CONFIG_BCM_SPDTEST
+            snprintf(errstr, len, "bad block size (maximum = %d bytes, minimum for UDP with HW offload = %d bytes)",
+                MAX_BLOCKSIZE, MIN_HW_UDP_BLKSIZE);
+#else
             snprintf(errstr, len, "block size too large (maximum = %d bytes)", MAX_BLOCKSIZE);
+#endif
             break;
         case IEBUFSIZE:
             snprintf(errstr, len, "socket buffer size too large (maximum = %d bytes)", MAX_TCP_BUFFER);
@@ -300,6 +305,10 @@ iperf_strerror(int int_errno)
         case IEACCESSDENIED:
             snprintf(errstr, len, "the server is busy running a test. try again later");
             break;
+        case IESETMARK:
+            snprintf(errstr, len, "unable to set socket SO_MARK");
+            perr = 1;
+            break;
         case IESETNODELAY:
             snprintf(errstr, len, "unable to set TCP/SCTP NODELAY");
             perr = 1;
@@ -350,6 +359,10 @@ iperf_strerror(int int_errno)
             snprintf(errstr, len, "send timeout value is incorrect or not in range");
             perr = 1;
             break;
+        case IEUDPSOFTWARE:
+            snprintf(errstr, len, "UDP client in driver mode not supported");
+            perr = 1;
+            break;
         case IERVRSONLYRCVTIMEOUT:
             snprintf(errstr, len, "client receive timeout is valid only in receiving mode");
             perr = 1;
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf.h iperf-3.12/src/iperf.h
--- orig_iperf-3.12/src/iperf.h	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf.h	2023-12-17 09:04:09.316605326 +0200
@@ -266,6 +266,12 @@ enum debug_level {
 
 struct iperf_test
 {
+#ifdef CONFIG_BCM_SPDTEST
+#define HW_OFFLOAD_MODE     1
+#define SW_OFFLOAD_MODE     2
+    int       hwoffl;                            /* 'H' stands for HW offload*/
+    int       legacy;                            /* 'o' using legacy iperf3 on the other side */
+#endif    
     char      role;                             /* 'c' lient or 's' erver */
     enum iperf_mode mode;
     int       sender_has_retransmits;
@@ -402,6 +408,9 @@ struct iperf_test
 #define SEC_TO_mS 1000
 #define SEC_TO_US 1000000LL
 #define UDP_RATE (1024 * 1024) /* 1 Mbps */
+#ifdef CONFIG_BCM_SPDTEST
+#define UDP_HW_RATE (UDP_RATE * 1024) /* 1 Gbps */
+#endif
 #define OMIT 0 /* seconds */
 #define DURATION 10 /* seconds */
 
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_locale.c iperf-3.12/src/iperf_locale.c
--- orig_iperf-3.12/src/iperf_locale.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_locale.c	2023-12-17 09:04:09.316605326 +0200
@@ -146,6 +146,9 @@ const char usage_longstr[] = "Usage: ipe
                            "                            and client during the authentication process\n"
 #endif //HAVE_SSL
                            "Client specific:\n"
+#ifdef CONFIG_BCM_SPDTEST
+                           "  -H, --hwoffl    [s]       run client in HW offload mode, 's' to force SW offload mode\n"
+#endif
                            "  -c, --client <host>[%%<dev>] run in client mode, connecting to <host>\n"
                            "                              (option <dev> equivalent to `--bind-dev <dev>`)\n"
 #if defined(HAVE_SCTP_H)
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_server_api.c iperf-3.12/src/iperf_server_api.c
--- orig_iperf-3.12/src/iperf_server_api.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_server_api.c	2023-12-17 09:05:30.647563187 +0200
@@ -123,6 +123,14 @@ iperf_accept(struct iperf_test *test)
     if (test->ctrl_sck == -1) {
         /* Server free, accept new client */
         test->ctrl_sck = s;
+#ifdef CONFIG_BCM_SPDTEST
+    // Give control socket a high prioirity
+    uint32_t mark = 7;
+    if (test->hwoffl && setsockopt(test->ctrl_sck, SOL_SOCKET, SO_MARK, &mark, sizeof(mark))) {
+        i_errno = IESETMARK;
+        return -1;
+    }
+#endif
         // set TCP_NODELAY for lower latency on control messages
         int flag = 1;
         if (setsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, sizeof(int))) {
@@ -234,11 +242,6 @@ iperf_handle_message_server(struct iperf
 
             // XXX: Remove this line below!
 	    iperf_err(test, "the client has terminated");
-            SLIST_FOREACH(sp, &test->streams, streams) {
-                FD_CLR(sp->socket, &test->read_set);
-                FD_CLR(sp->socket, &test->write_set);
-                close(sp->socket);
-            }
             test->state = IPERF_DONE;
             break;
         default:
@@ -262,6 +265,15 @@ server_timer_proc(TimerClientData client
     /* Free streams */
     while (!SLIST_EMPTY(&test->streams)) {
         sp = SLIST_FIRST(&test->streams);
+#ifdef CONFIG_BCM_SPDTEST
+            if (test->hwoffl)
+            {
+            int hw_fd = iperf_socket_to_stream(sp->socket);
+            iperf_set_stream_socket(hw_fd, -1);
+            iperf_hw_disconnect_sock(test, hw_fd);
+            spdt_uninit(hw_fd);
+            }
+#endif
         SLIST_REMOVE_HEAD(&test->streams, streams);
         close(sp->socket);
         iperf_free_stream(sp);
@@ -387,9 +399,20 @@ cleanup_server(struct iperf_test *test)
     /* Close open streams */
     SLIST_FOREACH(sp, &test->streams, streams) {
 	if (sp->socket > -1) {
+#ifdef CONFIG_BCM_SPDTEST
+            if (test->hwoffl)
+            {
+            int hw_fd = iperf_socket_to_stream(sp->socket);
+            iperf_set_stream_socket(hw_fd, -1);
+            iperf_hw_disconnect_sock(test, hw_fd);
+            spdt_uninit(hw_fd);
+            }
+#endif
+
             FD_CLR(sp->socket, &test->read_set);
             FD_CLR(sp->socket, &test->write_set);
             close(sp->socket);
+            sp->socket = -1;
 	}
     }
 
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_tcp.c iperf-3.12/src/iperf_tcp.c
--- orig_iperf-3.12/src/iperf_tcp.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_tcp.c	2023-12-17 09:04:09.317605325 +0200
@@ -48,6 +48,9 @@
 #include "flowlabel.h"
 #endif /* HAVE_FLOWLABEL */
 
+#ifdef CONFIG_BCM_SPDTEST
+#include "spdt_api.h"
+#endif
 /* iperf_tcp_recv
  *
  * receives the data for TCP
@@ -57,7 +60,11 @@ iperf_tcp_recv(struct iperf_stream *sp)
 {
     int r;
 
-    r = Nread(sp->socket, sp->buffer, sp->settings->blksize, Ptcp);
+    /* MSG_TRUNC flushes up to len bytes */
+    if (sp->test->zerocopy && (sp->test->state == TEST_RUNNING))
+        r = Nrecv(sp->socket, NULL, sp->settings->blksize, MSG_TRUNC);
+    else
+        r = Nread(sp->socket, sp->buffer, sp->settings->blksize, Ptcp);
 
     if (r < 0)
         return r;
@@ -359,6 +366,146 @@ iperf_tcp_listen(struct iperf_test *test
 }
 
 
+#ifdef CONFIG_BCM_SPDTEST
+int 
+iperf_tcp_hwoffl_recv(struct iperf_stream *sp)
+{
+    return 0;
+}
+
+int
+iperf_tcp_hwoffl_send(struct iperf_stream *sp)
+{
+    return 0;
+}
+
+extern uint8_t g_hw_fd;
+extern int g_connected;
+extern int g_fd_valid;
+
+int
+iperf_tcp_hwoffl_connect(struct iperf_test *test)
+{
+    uint8_t hw_fd;
+    spdt_conn_params_t params = {};
+    struct addrinfo hints, *local_res, *server_res;
+    char portstr[6];
+    int rc, connected = 0;
+
+    memset(&hints, 0, sizeof(hints));
+
+    rc = spdt_init(SPDT_IPERF3_TCP, &hw_fd);
+    if (rc)
+    {
+        printf("spdt_init failed\n");
+        i_errno = IESTREAMCONNECT;
+        return -1;  
+    }
+
+    g_hw_fd = hw_fd;
+    g_connected = 0;
+    g_fd_valid = 1;
+
+    memset(&params.local_addr, 0, sizeof(params.local_addr));
+
+    if (test->bind_address) 
+    {
+        memset(&hints, 0, sizeof(hints));
+        hints.ai_family = test->settings->domain;
+        hints.ai_socktype = SOCK_STREAM;
+        if (getaddrinfo(test->bind_address, NULL, &hints, &local_res) != 0) {
+            i_errno = IESTREAMCONNECT;
+            goto error;
+        }
+        /* convert to sockaddr_storage */
+
+        memcpy(&params.local_addr, local_res->ai_addr, local_res->ai_addrlen);
+
+        /*may free addrinfo now */
+        freeaddrinfo(local_res);
+    }
+
+    /* get server's address */
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = test->settings->domain;
+    hints.ai_socktype = SOCK_STREAM;
+    snprintf(portstr, sizeof(portstr), "%d", test->server_port);
+    if (getaddrinfo(test->server_hostname, portstr, &hints, &server_res) != 0) {
+        spdt_uninit(hw_fd);
+        i_errno = IESTREAMCONNECT;
+        goto error;
+    }
+
+     /* convert to sockaddr_storage */
+    memset(&params.server_addr, 0, sizeof(params.server_addr));
+    memcpy(&params.server_addr, server_res->ai_addr, server_res->ai_addrlen);
+
+    /*may free addrinfo now */
+    freeaddrinfo(server_res);
+
+    if (test->settings->tos)
+       params.tos = test->settings->tos;
+
+    params.force_swoffl_mode = (SW_OFFLOAD_MODE == test->hwoffl ? 1 : 0);
+
+    /* try to connect */
+    rc = spdt_connect(hw_fd, test->mode == SENDER ? SPDT_DIR_TX : SPDT_DIR_RX, &params);
+    if (rc)
+    {
+        printf("spdt_connect failed\n");
+        spdt_uninit(hw_fd);
+        i_errno = IESTREAMCONNECT;
+        goto error;
+    }
+    connected = 1;
+    g_connected = 1;
+
+    if (test->mode != SENDER)
+    {
+        spdt_rx_params_t rx_params = {};
+
+        rc = spdt_recv_start(hw_fd, &rx_params);
+        if (rc)
+        {
+            printf("spdt_recv_start failed\n");
+            i_errno = IESTREAMCONNECT;
+            goto error;
+        }    
+    }
+
+    /*send cookie via OOB channel */
+    rc = spdt_oob_send(hw_fd, test->cookie, COOKIE_SIZE);
+    if (rc)
+    {
+        printf("spdt_oob_send failed\n");
+        i_errno = IESTREAMCONNECT;
+        goto error;
+    }
+
+    if (test->mode == SENDER)
+    {
+        spdt_tx_params_t tx_params = {};
+
+        rc = spdt_send_start(hw_fd, &tx_params);
+        if (rc)
+        {
+            printf("spdt_send_start failed\n");
+            i_errno = IESTREAMCONNECT;
+            goto error;
+        }    
+    }
+
+    g_fd_valid = 0;
+    return hw_fd;
+
+error:
+    g_fd_valid = 0;
+    if (connected)
+        spdt_disconnect(hw_fd);
+    spdt_uninit(hw_fd);
+    return -1;
+}
+#endif
 /* iperf_tcp_connect
  *
  * connect to a TCP stream listener
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_tcp.h iperf-3.12/src/iperf_tcp.h
--- orig_iperf-3.12/src/iperf_tcp.h	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_tcp.h	2023-12-17 09:04:09.317605325 +0200
@@ -59,5 +59,10 @@ int iperf_tcp_listen(struct iperf_test *
 
 int iperf_tcp_connect(struct iperf_test *);
 
+#ifdef CONFIG_BCM_SPDTEST
+int iperf_tcp_hwoffl_connect(struct iperf_test *);
+int iperf_tcp_hwoffl_recv(struct iperf_stream *);
+int iperf_tcp_hwoffl_send(struct iperf_stream *);
+#endif
 
 #endif
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_udp.c iperf-3.12/src/iperf_udp.c
--- orig_iperf-3.12/src/iperf_udp.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_udp.c	2023-12-17 09:04:09.317605325 +0200
@@ -61,6 +61,15 @@
 # endif
 #endif
 
+#include "iperf_config.h"
+#include <netinet/in.h>
+#include <netdb.h>
+
+
+#ifdef CONFIG_BCM_SPDTEST
+#include "spdt_api.h"
+#endif
+
 /* iperf_udp_recv
  *
  * receives the data for UDP
@@ -356,6 +365,9 @@ iperf_udp_buffercheck(struct iperf_test
     return rc;
 }
 
+uint8_t g_hw_fd = 255;
+int g_connected = 0;
+int g_fd_valid = 0;
 /*
  * iperf_udp_accept
  *
@@ -369,6 +381,12 @@ iperf_udp_accept(struct iperf_test *test
     socklen_t len;
     int       sz, s;
     int	      rc;
+#ifdef CONFIG_BCM_SPDTEST
+    uint8_t hw_fd;
+    spdt_conn_params_t params = {};
+    int connected = 0;
+    spdt_stream_options_t options = {};
+#endif
 
     /*
      * Get the current outstanding socket.  This socket will be used to handle
@@ -451,14 +469,79 @@ iperf_udp_accept(struct iperf_test *test
     FD_SET(test->prot_listener, &test->read_set);
     test->max_fd = (test->max_fd < test->prot_listener) ? test->prot_listener : test->max_fd;
 
+#ifdef CONFIG_BCM_SPDTEST
+    if (!test->hwoffl)
+        goto send_connect_reply;
+
+    rc = spdt_init(SPDT_IPERF3_UDP, &hw_fd);
+    if (rc)
+    {
+        i_errno = IESTREAMCONNECT;
+        return -1;
+    }
+
+    /* 
+     * Workaround:
+     * If the process terminates at this point, hw_fd (stream index) will not be freed. This
+     * causes a leak of index in the driver. Store the hw_fd here to release it in the surprise
+     * termination handler.
+     */
+    g_hw_fd = hw_fd;
+    g_connected = 0;
+    g_fd_valid = 1;
+
+    options.proto.udp_options.has_sock_fd = 1;
+    options.proto.udp_options.sock_fd = s;
+    rc = spdt_set_options(hw_fd, &options);
+    if (rc)
+    {
+        i_errno = IESTREAMCONNECT;
+        goto error;
+    }
+
+    memset(&params.server_addr, 0, sizeof(params.server_addr));
+    memcpy(&params.server_addr, &sa_peer, len);
+
+    rc = spdt_connect(hw_fd, test->mode == SENDER ? SPDT_DIR_TX: SPDT_DIR_RX, &params);
+    if (rc)
+    {
+        i_errno = IESTREAMCONNECT;
+        goto error;
+    }
+
+    connected = 1;
+    g_connected = 1;
+	
+send_connect_reply:
+#endif
     /* Let the client know we're ready "accept" another UDP "stream" */
     buf = UDP_CONNECT_REPLY;
     if (write(s, &buf, sizeof(buf)) < 0) {
         i_errno = IESTREAMWRITE;
-        return -1;
+        goto error;
     }
 
+#ifdef CONFIG_BCM_SPDTEST
+    iperf_set_stream_socket(hw_fd, s);
+
+    /* 
+     * Workaround:
+     * At this state the fd will be returned and stored in the streams list. Which will close it
+     * if process terminates. So reset values here to prevent double free
+     */
+    g_fd_valid = 0;
+#endif
+
     return s;
+
+error:
+#ifdef CONFIG_BCM_SPDTEST
+    g_fd_valid = 0;
+    if (connected)
+        iperf_hw_disconnect_sock(test, hw_fd);
+    spdt_uninit(hw_fd);
+#endif
+    return -1;
 }
 
 
@@ -610,5 +693,203 @@ iperf_udp_connect(struct iperf_test *tes
 int
 iperf_udp_init(struct iperf_test *test)
 {
+    int rc = 0;
+ #ifdef CONFIG_BCM_SPDTEST
+    uint8_t hw_fd;
+    struct iperf_stream *sp;
+
+    if (!test->hwoffl)
+        return 0;
+
+    SLIST_FOREACH(sp, &test->streams, streams) {
+        hw_fd = iperf_socket_to_stream(sp->socket);
+        if (test->mode != SENDER)
+        {
+            spdt_rx_params_t rx_params = {};
+
+            rc = spdt_recv_start(hw_fd, &rx_params);
+            if (rc)
+            {
+                printf("spdt_recv_start failed\n");
+                i_errno = IESTREAMCONNECT;
+                return rc;
+            }
+        }
+
+        if (test->mode == SENDER)
+        {
+            spdt_tx_params_t tx_params = {};
+
+            tx_params.proto.udp.data_buf_len = test->settings->blksize;
+            tx_params.proto.udp.total_bytes_to_send = test->settings->bytes;
+            tx_params.proto.udp.kbps = (uint32_t)(test->settings->rate / 1000);
+            rc = spdt_send_start(hw_fd, &tx_params);
+            if (rc)
+            {
+                printf("spdt_send_start failed\n");
+                i_errno = IESTREAMCONNECT;
+            }
+        }
+    }
+#endif
+
+    return rc;
+}
+
+#ifdef CONFIG_BCM_SPDTEST
+int 
+iperf_udp_hwoffl_recv(struct iperf_stream *sp)
+{
     return 0;
 }
+
+int
+iperf_udp_hwoffl_send(struct iperf_stream *sp)
+{
+    return 0;
+}
+
+int
+iperf_udp_hwoffl_connect(struct iperf_test *test)
+{
+    uint8_t hw_fd;
+    spdt_conn_params_t params = {};
+    struct addrinfo hints, *local_res, *server_res;
+    char portstr[6];
+    int rc, connected = 0;
+    int buf;
+    uint32_t i, max_len_wait_for_reply, received;
+
+    memset(&hints, 0, sizeof(hints));
+
+    rc = spdt_init(SPDT_IPERF3_UDP, &hw_fd);
+    if (rc)
+    {
+        printf("spdt_init failed\n");
+        i_errno = IESTREAMCONNECT;
+        return -1;  
+    }
+
+    /* 
+     * Workaround:
+     * If the process terminates at this point, hw_fd (stream index) will not be freed. This
+     * causes a leak of index in the driver. Store the hw_fd here to release it in the surprise
+     * termination handler.
+     */
+    g_hw_fd = hw_fd;
+    g_connected = 0;
+    g_fd_valid = 1;
+
+    memset(&params.local_addr, 0, sizeof(params.local_addr));
+
+    if (test->bind_address) 
+    {
+        memset(&hints, 0, sizeof(hints));
+        hints.ai_family = test->settings->domain;
+        hints.ai_socktype = SOCK_DGRAM;
+        if (getaddrinfo(test->bind_address, NULL, &hints, &local_res) != 0) {
+            i_errno = IESTREAMCONNECT;
+            goto error;
+        }
+        /* convert to sockaddr_storage */
+
+        memcpy(&params.local_addr, local_res->ai_addr, local_res->ai_addrlen);
+
+        /*may free addrinfo now */
+        freeaddrinfo(local_res);
+    }
+
+    /* get server's address */
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = test->settings->domain;
+    hints.ai_socktype = SOCK_DGRAM;
+    snprintf(portstr, sizeof(portstr), "%d", test->server_port);
+    if (getaddrinfo(test->server_hostname, portstr, &hints, &server_res) != 0) {
+        spdt_uninit(hw_fd);
+        i_errno = IESTREAMCONNECT;
+        goto error;
+    }
+
+     /* convert to sockaddr_storage */
+    memset(&params.server_addr, 0, sizeof(params.server_addr));
+    memcpy(&params.server_addr, server_res->ai_addr, server_res->ai_addrlen);
+
+    /*may free addrinfo now */
+    freeaddrinfo(server_res);
+
+    if (test->settings->tos)
+       params.tos = test->settings->tos;
+
+    /* try to connect */
+    rc = spdt_connect(hw_fd, test->mode == SENDER ? SPDT_DIR_TX: SPDT_DIR_RX, &params);
+    if (rc)
+    {
+        printf("spdt_connect failed\n");
+        i_errno = IESTREAMCONNECT;
+        goto error;
+    }
+    connected = 1;
+    g_connected = 1;
+
+    /*
+     * Write a datagram to the UDP stream to let the server know we're here.
+     * The server learns our address by obtaining its peer's address.
+     */
+    buf = 123456789;		/* this can be pretty much anything */
+    rc = spdt_oob_send(hw_fd, (char *)&buf, sizeof(buf));
+    if (rc < 0)
+    {
+        printf("%s:%d Failed to send start indication to the server, rc = %d\n", __FUNCTION__, __LINE__, rc);
+        i_errno = IESTREAMWRITE;
+        goto error;
+    }
+
+    /*
+     * Wait until the server replies back to us with the "accept" response.
+     */
+    i = 0;
+    max_len_wait_for_reply = sizeof(buf);
+    /* In reverse mode allow few packets to have the "accept" response - to handle out of order packets */
+    if (test->reverse)
+        max_len_wait_for_reply += MAX_REVERSE_OUT_OF_ORDER_PACKETS * test->settings->blksize;
+
+    do
+    {
+        rc = spdt_msg_receive(hw_fd, (char *)&buf, sizeof(buf), &received);
+        if (rc)
+        {
+            i_errno = IESTREAMREAD;
+            goto error;
+        }
+        if (test->debug)
+        {
+            printf("Connect received for Socket %d, sz=%d, buf=%x, i=%d, max_len_wait_for_reply=%d\n",
+                hw_fd, received, buf, i, max_len_wait_for_reply);
+        }
+        i += received;
+    } while (buf != UDP_CONNECT_REPLY && buf != LEGACY_UDP_CONNECT_REPLY && i < max_len_wait_for_reply);
+
+    if (buf != UDP_CONNECT_REPLY  && buf != LEGACY_UDP_CONNECT_REPLY)
+    {
+        i_errno = IESTREAMREAD;
+        goto error;
+    }
+
+    /* 
+     * Workaround:
+     * At this state the fd will be returned and stored in the streams list. Which will close it
+     * if process terminates. So reset values here to prevent double free
+     */
+    g_fd_valid = 0;
+
+    return hw_fd;
+
+error:
+    g_fd_valid = 0;
+    if (connected)
+        iperf_hw_disconnect_sock(test, hw_fd);
+    spdt_uninit(hw_fd);
+    return -1;
+}
+#endif
+
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/iperf_udp.h iperf-3.12/src/iperf_udp.h
--- orig_iperf-3.12/src/iperf_udp.h	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/iperf_udp.h	2023-12-17 09:04:09.317605325 +0200
@@ -60,5 +60,10 @@ int iperf_udp_connect(struct iperf_test
 
 int iperf_udp_init(struct iperf_test *);
 
+#ifdef CONFIG_BCM_SPDTEST
+int iperf_udp_hwoffl_recv(struct iperf_stream *sp);
+int iperf_udp_hwoffl_send(struct iperf_stream *sp);
+int iperf_udp_hwoffl_connect(struct iperf_test *test);
+#endif
 
 #endif
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/main.c iperf-3.12/src/main.c
--- orig_iperf-3.12/src/main.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/main.c	2023-12-17 09:04:09.317605325 +0200
@@ -49,6 +49,14 @@
 #include "net.h"
 #include "units.h"
 
+#ifdef CONFIG_BCM_SPDTEST
+#include "spdt_api.h"
+
+extern uint8_t g_hw_fd;
+extern int g_connected;
+extern int g_fd_valid;
+static struct iperf_test *g_test = NULL;
+#endif
 
 static int run(struct iperf_test *test);
 
@@ -97,6 +105,9 @@ main(int argc, char **argv)
     if (!test)
         iperf_errexit(NULL, "create new test error - %s", iperf_strerror(i_errno));
     iperf_defaults(test);	/* sets defaults */
+#ifdef CONFIG_BCM_SPDTEST
+    g_test = test;
+#endif
 
     if (iperf_parse_arguments(test, argc, argv) < 0) {
         iperf_err(test, "parameter error - %s", iperf_strerror(i_errno));
@@ -119,6 +130,17 @@ static jmp_buf sigend_jmp_buf;
 static void __attribute__ ((noreturn))
 sigend_handler(int sig)
 {
+#ifdef CONFIG_BCM_SPDTEST
+    if (g_fd_valid)
+    {
+        g_fd_valid = 0;
+        if (g_connected)
+            iperf_hw_disconnect_sock(g_test, g_hw_fd);
+        spdt_uninit(g_hw_fd);
+    }
+    if (g_test->hwoffl)
+        iperf_hw_uninit(g_test);
+#endif
     longjmp(sigend_jmp_buf, 1);
 }
 
@@ -141,27 +163,26 @@ run(struct iperf_test *test)
 		rc = daemon(0, 0);
 		if (rc < 0) {
 		    i_errno = IEDAEMON;
-		    iperf_errexit(test, "error - %s", iperf_strerror(i_errno));
+                    goto error;
 		}
 	    }
 	    if (iperf_create_pidfile(test) < 0) {
 		i_errno = IEPIDFILE;
-		iperf_errexit(test, "error - %s", iperf_strerror(i_errno));
+                goto error;
 	    }
             for (;;) {
 		int rc;
 		rc = iperf_run_server(test);
                 test->server_last_run_rc =rc;
 		if (rc < 0) {
-		    iperf_err(test, "error - %s", iperf_strerror(i_errno));
-                    if (test->json_output) {
+		    if (test->json_output) {
                         if (iperf_json_finish(test) < 0)
-                            return -1;
+                            goto error;
                     }
                     iflush(test);
 
 		    if (rc < -1) {
-		        iperf_errexit(test, "exiting");
+                        goto error;
 		    }
                 }
                 iperf_reset_test(test);
@@ -181,7 +202,7 @@ run(struct iperf_test *test)
 		iperf_errexit(test, "error - %s", iperf_strerror(i_errno));
 	    }
 	    if (iperf_run_client(test) < 0)
-		iperf_errexit(test, "error - %s", iperf_strerror(i_errno));
+		goto error;
 	    iperf_delete_pidfile(test);
             break;
         default:
@@ -193,4 +214,12 @@ run(struct iperf_test *test)
     signal(SIGPIPE, SIG_DFL);
 
     return 0;
+
+error:
+#ifdef CONFIG_BCM_SPDTEST
+    if (test->hwoffl)
+        iperf_hw_uninit(test);
+#endif
+    iperf_errexit(test, "error - %s", iperf_strerror(i_errno));
+    return -1;
 }
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/net.c iperf-3.12/src/net.c
--- orig_iperf-3.12/src/net.c	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/net.c	2023-12-17 09:04:09.317605325 +0200
@@ -389,6 +389,16 @@ Nread(int fd, char *buf, size_t count, i
     return count - nleft;
 }
 
+int
+Nrecv(int fd, char *buf, size_t count, int flags)
+{
+    int ret;
+
+    ret = recv(fd, buf, count, flags);
+
+    return ret;
+}
+
 
 /*
  *                      N W R I T E
diff -rupN -x '*.o' -x '*.Po' -x '\.deps*' -x iperf3 -x '*.lo' -x '*.orig' -x iperf_config.h -x 'libiperf.*' -x t_timer -x Makefile -x stamp-h1 -x t_units -x t_uuid -x version.h orig_iperf-3.12/src/net.h iperf-3.12/src/net.h
--- orig_iperf-3.12/src/net.h	2022-09-30 21:49:24.000000000 +0300
+++ iperf-3.12/src/net.h	2023-12-17 09:04:09.317605325 +0200
@@ -32,6 +32,7 @@ int create_socket(int domain, int proto,
 int netdial(int domain, int proto, const char *local, const char *bind_dev, int local_port, const char *server, int port, int timeout);
 int netannounce(int domain, int proto, const char *local, const char *bind_dev, int port);
 int Nread(int fd, char *buf, size_t count, int prot);
+int Nrecv(int fd, char *buf, size_t count, int flags);
 int Nwrite(int fd, const char *buf, size_t count, int prot) /* __attribute__((hot)) */;
 int has_sendfile(void);
 int Nsendfile(int fromfd, int tofd, const char *buf, size_t count) /* __attribute__((hot)) */;
