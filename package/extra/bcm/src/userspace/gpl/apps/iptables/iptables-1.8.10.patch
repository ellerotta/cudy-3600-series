diff -urN orig_iptables-1.8.9/extensions/libxt_blog.c iptables-1.8.9/extensions/libxt_blog.c
--- orig_iptables-1.8.9/extensions/libxt_blog.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_blog.c	2023-02-01 14:39:50.249957907 +0800
@@ -0,0 +1,85 @@
+/* Shared library add-on to iptables to add blog match support. */
+#include <stdbool.h>
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <netinet/in.h>
+#include <xtables.h>
+#include <linux/netfilter/xt_blog.h>
+
+static void blog_match_help(void)
+{
+	printf(
+"blog match options:\n"
+"[!] --tcp-pureack              match when blog TCP Pure ACK is\n"
+"                               detected.\n");
+}
+
+static const struct option blog_match_opts[] = {
+	{.name = "tcp-pureack",      .has_arg = false, .val = '1'},
+	XT_GETOPT_TABLEEND,
+};
+
+static int
+blog_match_parse(int c, char **argv, int invert, unsigned int *flags,
+          const void *entry, struct xt_entry_match **match)
+{
+	struct xt_blog *bloginfo = (struct xt_blog *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		bloginfo->tcp_pure_ack = 1;
+		bloginfo->invert = invert;
+		break;
+	}
+
+	return 1;
+}
+
+static void
+blog_match_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_blog *bloginfo = (struct xt_blog *)match->data;
+
+	printf(" blog");
+	if (bloginfo->tcp_pure_ack)
+		printf(" TCP Pure ACK");
+	if (bloginfo->invert)
+		printf(" not detected");
+	else
+		printf(" detected");
+}
+
+static void
+blog_match_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_blog *bloginfo = (struct xt_blog *)match->data;
+
+	printf(" blog");
+	if (bloginfo->tcp_pure_ack) {
+		if (bloginfo->invert)
+			printf(" !");
+		printf(" --tcp-pureack ");
+	}
+}
+
+static struct xtables_match blog_match = {
+	.family		= NFPROTO_UNSPEC,
+	.name		= "blog",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct xt_blog)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_blog)),
+	.help		= blog_match_help,
+	.parse		= blog_match_parse,
+	.print		= blog_match_print,
+	.save		= blog_match_save,
+	.extra_opts	= blog_match_opts,
+};
+
+void
+_init(void)
+{
+	xtables_register_match(&blog_match);
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_connlimit.c iptables-1.8.9/extensions/libxt_connlimit.c
--- orig_iptables-1.8.9/extensions/libxt_connlimit.c	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_connlimit.c	2023-02-01 14:39:50.253958228 +0800
@@ -12,6 +12,7 @@
 	O_MASK,
 	O_SADDR,
 	O_DADDR,
+	O_DADDR_DPORT,
 	F_UPTO  = 1 << O_UPTO,
 	F_ABOVE = 1 << O_ABOVE,
 	F_MASK  = 1 << O_MASK,
@@ -27,7 +28,8 @@
 "  --connlimit-above n    match if the number of existing connections is >n\n"
 "  --connlimit-mask n     group hosts using prefix length (default: max len)\n"
 "  --connlimit-saddr      select source address for grouping\n"
-"  --connlimit-daddr      select destination addresses for grouping\n");
+"  --connlimit-daddr      select destination addresses for grouping\n"
+"  --connlimit-daddr-dport      select destination addresses for grouping\n");
 }
 
 #define s struct xt_connlimit_info
@@ -44,6 +46,8 @@
 	 .type = XTTYPE_NONE},
 	{.name = "connlimit-daddr", .id = O_DADDR, .excl = F_SADDR,
 	 .type = XTTYPE_NONE},
+	{.name = "connlimit-daddr-dport", .id = O_DADDR_DPORT, .excl = F_SADDR,
+	 .type = XTTYPE_NONE},
 	XTOPT_TABLEEND,
 };
 #undef s
@@ -85,6 +89,16 @@
 				"--connlimit-daddr");
 		info->flags |= XT_CONNLIMIT_DADDR;
 		break;
+	case O_DADDR_DPORT:
+		if (revision < 1) 
+			xtables_error(PARAMETER_PROBLEM,
+				"xt_connlimit.0 does not support "
+				"--connlimit-daddr-dport");
+		if (family != NFPROTO_IPV4) 
+			xtables_error(PARAMETER_PROBLEM,
+				" --connlimit-daddr-dport is supported only for IPV4 ");
+		info->flags |= XT_CONNLIMIT_DADDR_DPORT;
+		break;
 	}
 }
 
@@ -133,7 +147,7 @@
 	const struct xt_connlimit_info *info = (const void *)match->data;
 
 	printf(" #conn %s/%u %s %u",
-	       (info->flags & XT_CONNLIMIT_DADDR) ? "dst" : "src",
+		   (info->flags & XT_CONNLIMIT_DADDR_DPORT) ? "dstip+dport" : ((info->flags & XT_CONNLIMIT_DADDR) ? "dst" : "src"),
 	       count_bits4(info->v4_mask),
 	       (info->flags & XT_CONNLIMIT_INVERT) ? "<=" : ">", info->limit);
 }
@@ -160,7 +174,9 @@
 		printf(" --connlimit-above %u", info->limit);
 	printf(" --connlimit-mask %u", count_bits4(info->v4_mask));
 	if (revision >= 1) {
-		if (info->flags & XT_CONNLIMIT_DADDR)
+		if (info->flags & XT_CONNLIMIT_DADDR_DPORT)
+			printf(" --connlimit-daddr-dport");
+		else if (info->flags & XT_CONNLIMIT_DADDR)
 			printf(" --connlimit-daddr");
 		else
 			printf(" --connlimit-saddr");
diff -urN orig_iptables-1.8.9/extensions/libxt_flowlabel.c iptables-1.8.9/extensions/libxt_flowlabel.c
--- orig_iptables-1.8.9/extensions/libxt_flowlabel.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_flowlabel.c	2023-02-01 14:39:50.249957907 +0800
@@ -0,0 +1,106 @@
+/*
+ * Shared library add-on to iptables to add IPv6 flowlabel match support
+ *
+ * BRCM, Feb, 1. 2019.
+ */
+ 
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <netdb.h>
+#include <stdbool.h>
+#include <xtables.h>
+#include <linux/types.h>
+
+#include "linux/netfilter/xt_flowlabel.h"
+
+enum {
+	O_FLOWLABEL = 1 << 0,
+};
+
+
+static const struct xt_option_entry flowlabel_mt_opts[] = {
+	{.name = "flowlabel", .id = O_FLOWLABEL, .type = XTTYPE_UINT32,
+	 .flags = XTOPT_INVERT | XTOPT_MAND, .max = XT_FLOWLABEL_MAX},
+	XTOPT_TABLEEND,
+};
+
+static void flowlabel_mt_help(void)
+{
+	printf(
+"flowlabel match options:\n"
+"[!] --flowlabel value    Match IPv6 flowlabel field value\n"
+"                         Max value: 0x%05X\n", XT_FLOWLABEL_MAX);
+}
+
+static void flowlabel_mt_parse(struct xt_option_call *cb)
+{
+	struct xt_flowlabel_info *info = cb->data;
+
+	xtables_option_parse(cb);
+	info->flowlabel = cpu_to_be32(cb->val.u32);
+	if (cb->invert)
+		info->invert = true;
+}
+
+static void flowlabel_mt_check(struct xt_fcheck_call *cb)
+{
+	if (cb->xflags == 0)
+		xtables_error(PARAMETER_PROBLEM,
+		      "flowlabel match: Parameter --flowlabel is required");
+}
+
+static int flowlabel_mt_xlate(struct xt_xlate *xl,
+			const struct xt_xlate_mt_params *params)
+{
+	const struct xt_flowlabel_info *info =
+		(const struct xt_flowlabel_info *)params->match->data;
+
+	xt_xlate_add(xl, "flowlabel %s0x%05X", info->invert ? "!= " : "",
+		     be32_to_cpu(info->flowlabel));
+
+	return 1;
+}
+
+static void flowlabel_mt_print(const void *ip, const struct xt_entry_match *match,
+                         int numeric)
+{
+	const struct xt_flowlabel_info *info = (const void *)match->data;
+
+	printf(" flowlabel match ");
+	if (info->invert)
+		printf("!");
+
+	printf("0x%05X", be32_to_cpu(info->flowlabel));
+}
+
+static void flowlabel_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_flowlabel_info *info = (const void *)match->data;
+
+	if (info->invert)
+		printf(" !");
+	printf(" --flowlabel 0x%05X", be32_to_cpu(info->flowlabel));
+}
+
+static struct xtables_match flowlabel_mt_reg = {
+	.family        = NFPROTO_IPV6,
+	.name          = "flowlabel",
+	.version       = XTABLES_VERSION,
+	.size          = XT_ALIGN(sizeof(struct xt_flowlabel_info)),
+	.userspacesize = XT_ALIGN(sizeof(struct xt_flowlabel_info)),
+	.help          = flowlabel_mt_help,
+	.print         = flowlabel_mt_print,
+	.save          = flowlabel_mt_save,
+	.x6_parse      = flowlabel_mt_parse,
+	.x6_fcheck     = flowlabel_mt_check,
+	.xlate         = flowlabel_mt_xlate,
+	.x6_options    = flowlabel_mt_opts,
+
+};
+
+void _init(void)
+{
+	xtables_register_match(&flowlabel_mt_reg);
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_mac_extend.c iptables-1.8.9/extensions/libxt_mac_extend.c
--- orig_iptables-1.8.9/extensions/libxt_mac_extend.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_mac_extend.c	2023-02-01 14:39:50.249957907 +0800
@@ -0,0 +1,156 @@
+
+/* extend from libxt_mac.c for MAC address extend match operations,
+ * i.e, MAC/mask. 
+ * BRCM, Jan, 31. 2019.
+ */
+
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#if defined(__GLIBC__) && __GLIBC__ == 2
+#include <net/ethernet.h>
+#else
+#include <linux/if_ether.h>
+#endif
+#include <xtables.h>
+#include <linux/netfilter/xt_mac_extend.h>
+
+enum {
+	O_MAC = 0,
+};
+
+static void mac_help(void)
+{
+	printf(
+"mac extend match options:\n"
+"[!] --mac-source-extend[/mask] XX:XX:XX:XX:XX:XX/FF:FF:FF:00:00:00\n"
+"				Match source MAC address/mask\n");
+}
+
+#define s struct xt_mac_info_extend
+static const struct xt_option_entry mac_opts[] = {
+	{.name = "mac-source-extend", .id = O_MAC, .type = XTTYPE_ETHERMAC,
+	 .flags = XTOPT_MAND | XTOPT_INVERT | XTOPT_PUT,
+	 XTOPT_POINTER(s, srcaddr)},
+	XTOPT_TABLEEND,
+};
+#undef s
+
+static int mac_mask(char *mask_in, unsigned char *mask_out)
+{
+	const char *arg = mask_in;
+	unsigned int i;
+	char *end;
+
+	for (i = 0; i < ETH_ALEN; ++i) {
+		mask_out[i] = strtoul(arg, &end, 16);
+		if (((i < (ETH_ALEN - 1)) && (*end != ':')) ||
+			((i == (ETH_ALEN - 1)) && (*end != '\0' )) || 
+			(end - arg > 2))
+			return -1;
+		arg = end + 1;
+	}
+	return 0;
+}
+
+static void mac_parse(struct xt_option_call *cb)
+{
+	struct xt_mac_info_extend *macinfo = cb->data;
+	char *p;
+
+	/* first the mask */
+	if ((p = strrchr(cb->arg, '/')) != NULL) {
+		*p = '\0';
+		if (mac_mask(p + 1, macinfo->msk)) {
+			xtables_error(PARAMETER_PROBLEM,
+				      "Problem with the MAC mask '%s'", p + 1);
+			return;
+		}
+	} else {
+		/* default mask = FF:FF:FF:FF:FF:FF */
+		int i;
+		for (i = 0; i < ETH_ALEN; i++) {
+			macinfo->msk[i] = 0xFF;
+		}
+	}
+    
+	xtables_option_parse(cb);
+	if (cb->invert)
+		macinfo->invert = 1;
+}
+
+static void print_mac(const unsigned char *macaddress)
+{
+	unsigned int i;
+
+	printf(" %02X", macaddress[0]);
+	for (i = 1; i < ETH_ALEN; ++i)
+		printf(":%02X", macaddress[i]);
+}
+
+static void
+mac_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_mac_info_extend *info = (void *)match->data;
+
+	printf(" MAC");
+
+	if (info->invert)
+		printf(" !");
+
+	print_mac(info->srcaddr);
+	printf(" /");
+	print_mac(info->msk);
+}
+
+static void mac_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_mac_info_extend *info = (void *)match->data;
+
+	if (info->invert)
+		printf(" !");
+
+	printf(" --mac-source");
+	print_mac(info->srcaddr);
+}
+
+static void print_mac_xlate(const unsigned char *macaddress,
+			    struct xt_xlate *xl)
+{
+	unsigned int i;
+
+	xt_xlate_add(xl, "%02x", macaddress[0]);
+	for (i = 1; i < ETH_ALEN; ++i)
+		xt_xlate_add(xl, ":%02x", macaddress[i]);
+}
+
+static int mac_xlate(struct xt_xlate *xl,
+		     const struct xt_xlate_mt_params *params)
+{
+	const struct xt_mac_info_extend *info = (void *)params->match->data;
+
+	xt_xlate_add(xl, "ether saddr%s ", info->invert ? " !=" : "");
+	print_mac_xlate(info->srcaddr, xl);
+
+	return 1;
+}
+
+static struct xtables_match mac_match = {
+	.family		= NFPROTO_UNSPEC,
+	.name		= "mac-extend",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct xt_mac_info_extend)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_mac_info_extend)),
+	.help		= mac_help,
+	.x6_parse	= mac_parse,
+	.print		= mac_print,
+	.save		= mac_save,
+	.x6_options	= mac_opts,
+	.xlate		= mac_xlate,
+};
+
+void _init(void)
+{
+	xtables_register_match(&mac_match);
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_MARK_extend.c iptables-1.8.9/extensions/libxt_MARK_extend.c
--- orig_iptables-1.8.9/extensions/libxt_MARK_extend.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_MARK_extend.c	2023-02-01 14:39:50.257958549 +0800
@@ -0,0 +1,445 @@
+
+/* Extend from libxt_MARK.c.
+ *  Change targets from non-terminating to terminating.
+ *  BRCM, Apr, 22. 2022.
+ */
+
+
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <xtables.h>
+#include <linux/netfilter/xt_MARK.h>
+
+/* Version 0 */
+struct xt_mark_target_info {
+	unsigned long mark;
+};
+
+/* Version 1 */
+enum {
+	XT_MARK_SET=0,
+	XT_MARK_AND,
+	XT_MARK_OR,
+};
+
+struct xt_mark_target_info_v1 {
+	unsigned long mark;
+	uint8_t mode;
+};
+
+enum {
+	O_SET_MARK = 0,
+	O_AND_MARK,
+	O_OR_MARK,
+	O_XOR_MARK,
+	O_SET_XMARK,
+	F_SET_MARK  = 1 << O_SET_MARK,
+	F_AND_MARK  = 1 << O_AND_MARK,
+	F_OR_MARK   = 1 << O_OR_MARK,
+	F_XOR_MARK  = 1 << O_XOR_MARK,
+	F_SET_XMARK = 1 << O_SET_XMARK,
+	F_ANY       = F_SET_MARK | F_AND_MARK | F_OR_MARK |
+	              F_XOR_MARK | F_SET_XMARK,
+};
+
+static void MARK_help(void)
+{
+	printf(
+"MARK-EXTEND target options:\n"
+"  --set-mark value                   Set nfmark value\n"
+"  --and-mark value                   Binary AND the nfmark with value\n"
+"  --or-mark  value                   Binary OR  the nfmark with value\n");
+}
+
+static const struct xt_option_entry MARK_opts[] = {
+	{.name = "set-mark", .id = O_SET_MARK, .type = XTTYPE_UINT32,
+	 .excl = F_ANY},
+	{.name = "and-mark", .id = O_AND_MARK, .type = XTTYPE_UINT32,
+	 .excl = F_ANY},
+	{.name = "or-mark", .id = O_OR_MARK, .type = XTTYPE_UINT32,
+	 .excl = F_ANY},
+	XTOPT_TABLEEND,
+};
+
+static const struct xt_option_entry mark_tg_opts[] = {
+	{.name = "set-xmark", .id = O_SET_XMARK, .type = XTTYPE_MARKMASK32,
+	 .excl = F_ANY},
+	{.name = "set-mark", .id = O_SET_MARK, .type = XTTYPE_MARKMASK32,
+	 .excl = F_ANY},
+	{.name = "and-mark", .id = O_AND_MARK, .type = XTTYPE_UINT32,
+	 .excl = F_ANY},
+	{.name = "or-mark", .id = O_OR_MARK, .type = XTTYPE_UINT32,
+	 .excl = F_ANY},
+	{.name = "xor-mark", .id = O_XOR_MARK, .type = XTTYPE_UINT32,
+	 .excl = F_ANY},
+	XTOPT_TABLEEND,
+};
+
+static void mark_tg_help(void)
+{
+	printf(
+"MARK-EXTEND target options:\n"
+"  --set-xmark value[/mask]  Clear bits in mask and XOR value into nfmark\n"
+"  --set-mark value[/mask]   Clear bits in mask and OR value into nfmark\n"
+"  --and-mark bits           Binary AND the nfmark with bits\n"
+"  --or-mark bits            Binary OR the nfmark with bits\n"
+"  --xor-mark bits           Binary XOR the nfmark with bits\n"
+"\n");
+}
+
+static void MARK_parse_v0(struct xt_option_call *cb)
+{
+	struct xt_mark_target_info *markinfo = cb->data;
+
+	xtables_option_parse(cb);
+	switch (cb->entry->id) {
+	case O_SET_MARK:
+		markinfo->mark = cb->val.mark;
+		break;
+	default:
+		xtables_error(PARAMETER_PROBLEM,
+			   "MARK-EXTEND target: kernel too old for --%s",
+			   cb->entry->name);
+	}
+}
+
+static void MARK_check(struct xt_fcheck_call *cb)
+{
+	if (cb->xflags == 0)
+		xtables_error(PARAMETER_PROBLEM,
+		           "MARK-EXTEND target: Parameter --set/and/or-mark"
+			   " is required");
+}
+
+static void MARK_parse_v1(struct xt_option_call *cb)
+{
+	struct xt_mark_target_info_v1 *markinfo = cb->data;
+
+	xtables_option_parse(cb);
+	switch (cb->entry->id) {
+	case O_SET_MARK:
+	        markinfo->mode = XT_MARK_SET;
+		break;
+	case O_AND_MARK:
+	        markinfo->mode = XT_MARK_AND;
+		break;
+	case O_OR_MARK:
+	        markinfo->mode = XT_MARK_OR;
+		break;
+	}
+	markinfo->mark = cb->val.u32;
+}
+
+static void mark_tg_parse(struct xt_option_call *cb)
+{
+	struct xt_mark_tginfo2 *info = cb->data;
+
+	xtables_option_parse(cb);
+	switch (cb->entry->id) {
+	case O_SET_XMARK:
+		info->mark = cb->val.mark;
+		info->mask = cb->val.mask;
+		break;
+	case O_SET_MARK:
+		info->mark = cb->val.mark;
+		info->mask = cb->val.mark | cb->val.mask;
+		break;
+	case O_AND_MARK:
+		info->mark = 0;
+		info->mask = ~cb->val.u32;
+		break;
+	case O_OR_MARK:
+		info->mark = info->mask = cb->val.u32;
+		break;
+	case O_XOR_MARK:
+		info->mark = cb->val.u32;
+		info->mask = 0;
+		break;
+	}
+}
+
+static void mark_tg_check(struct xt_fcheck_call *cb)
+{
+	if (cb->xflags == 0)
+		xtables_error(PARAMETER_PROBLEM, "MARK-EXTEND: One of the --set-xmark, "
+		           "--{and,or,xor,set}-mark options is required");
+}
+
+static void
+print_mark(unsigned long mark)
+{
+	printf(" 0x%lx", mark);
+}
+
+static void MARK_print_v0(const void *ip,
+                          const struct xt_entry_target *target, int numeric)
+{
+	const struct xt_mark_target_info *markinfo =
+		(const struct xt_mark_target_info *)target->data;
+	printf(" MARK set");
+	print_mark(markinfo->mark);
+}
+
+static void MARK_save_v0(const void *ip, const struct xt_entry_target *target)
+{
+	const struct xt_mark_target_info *markinfo =
+		(const struct xt_mark_target_info *)target->data;
+
+	printf(" --set-mark");
+	print_mark(markinfo->mark);
+}
+
+static void MARK_print_v1(const void *ip, const struct xt_entry_target *target,
+                          int numeric)
+{
+	const struct xt_mark_target_info_v1 *markinfo =
+		(const struct xt_mark_target_info_v1 *)target->data;
+
+	switch (markinfo->mode) {
+	case XT_MARK_SET:
+		printf(" MARK set");
+		break;
+	case XT_MARK_AND:
+		printf(" MARK and");
+		break;
+	case XT_MARK_OR:
+		printf(" MARK or");
+		break;
+	}
+	print_mark(markinfo->mark);
+}
+
+static void mark_tg_print(const void *ip, const struct xt_entry_target *target,
+                          int numeric)
+{
+	const struct xt_mark_tginfo2 *info = (const void *)target->data;
+
+	if (info->mark == 0)
+		printf(" MARK and 0x%x", (unsigned int)(uint32_t)~info->mask);
+	else if (info->mark == info->mask)
+		printf(" MARK or 0x%x", info->mark);
+	else if (info->mask == 0)
+		printf(" MARK xor 0x%x", info->mark);
+	else if (info->mask == 0xffffffffU)
+		printf(" MARK set 0x%x", info->mark);
+	else
+		printf(" MARK xset 0x%x/0x%x", info->mark, info->mask);
+}
+
+static void MARK_save_v1(const void *ip, const struct xt_entry_target *target)
+{
+	const struct xt_mark_target_info_v1 *markinfo =
+		(const struct xt_mark_target_info_v1 *)target->data;
+
+	switch (markinfo->mode) {
+	case XT_MARK_SET:
+		printf(" --set-mark");
+		break;
+	case XT_MARK_AND:
+		printf(" --and-mark");
+		break;
+	case XT_MARK_OR:
+		printf(" --or-mark");
+		break;
+	}
+	print_mark(markinfo->mark);
+}
+
+static void mark_tg_save(const void *ip, const struct xt_entry_target *target)
+{
+	const struct xt_mark_tginfo2 *info = (const void *)target->data;
+
+	printf(" --set-xmark 0x%x/0x%x", info->mark, info->mask);
+}
+
+static void mark_tg_arp_save(const void *ip, const struct xt_entry_target *target)
+{
+	const struct xt_mark_tginfo2 *info = (const void *)target->data;
+
+	if (info->mark == 0)
+		printf(" --and-mark %x", (unsigned int)(uint32_t)~info->mask);
+	else if (info->mark == info->mask)
+		printf(" --or-mark %x", info->mark);
+	else
+		printf(" --set-mark %x", info->mark);
+}
+
+static void mark_tg_arp_print(const void *ip,
+			      const struct xt_entry_target *target, int numeric)
+{
+	mark_tg_arp_save(ip, target);
+}
+
+#define MARK_OPT 1
+#define AND_MARK_OPT 2
+#define OR_MARK_OPT 3
+
+static struct option mark_tg_arp_opts[] = {
+	{ .name = "set-mark", .has_arg = required_argument, .flag = 0, .val = MARK_OPT },
+	{ .name = "and-mark", .has_arg = required_argument, .flag = 0, .val = AND_MARK_OPT },
+	{ .name = "or-mark", .has_arg = required_argument, .flag = 0, .val =  OR_MARK_OPT },
+	{ .name = NULL}
+};
+
+static int
+mark_tg_arp_parse(int c, char **argv, int invert, unsigned int *flags,
+		  const void *entry, struct xt_entry_target **target)
+{
+	struct xt_mark_tginfo2 *info =
+		(struct xt_mark_tginfo2 *)(*target)->data;
+	int i;
+
+	switch (c) {
+	case MARK_OPT:
+		if (sscanf(argv[optind-1], "%x", &i) != 1) {
+			xtables_error(PARAMETER_PROBLEM,
+				"Bad mark value `%s'", optarg);
+			return 0;
+		}
+		info->mark = i;
+		if (*flags)
+			xtables_error(PARAMETER_PROBLEM,
+				"MARK-EXTEND: Can't specify --set-mark twice");
+		*flags = 1;
+		break;
+	case AND_MARK_OPT:
+		if (sscanf(argv[optind-1], "%x", &i) != 1) {
+			xtables_error(PARAMETER_PROBLEM,
+				"Bad mark value `%s'", optarg);
+			return 0;
+		}
+		info->mark = 0;
+		info->mask = ~i;
+		if (*flags)
+			xtables_error(PARAMETER_PROBLEM,
+				"MARK-EXTEND: Can't specify --and-mark twice");
+		*flags = 1;
+		break;
+	case OR_MARK_OPT:
+		if (sscanf(argv[optind-1], "%x", &i) != 1) {
+			xtables_error(PARAMETER_PROBLEM,
+				"Bad mark value `%s'", optarg);
+			return 0;
+		}
+		info->mark = info->mask = i;
+		if (*flags)
+			xtables_error(PARAMETER_PROBLEM,
+				"MARK-EXTEND: Can't specify --or-mark twice");
+		*flags = 1;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static int mark_tg_xlate(struct xt_xlate *xl,
+			 const struct xt_xlate_tg_params *params)
+{
+	const struct xt_mark_tginfo2 *info = (const void *)params->target->data;
+
+	xt_xlate_add(xl, "meta mark set ");
+
+	if (info->mask == 0xffffffffU)
+		xt_xlate_add(xl, "0x%x ", info->mark);
+	else if (info->mark == 0)
+		xt_xlate_add(xl, "mark and 0x%x ", ~info->mask);
+	else if (info->mark == info->mask)
+		xt_xlate_add(xl, "mark or 0x%x ", info->mark);
+	else if (info->mask == 0)
+		xt_xlate_add(xl, "mark xor 0x%x ", info->mark);
+	else
+		xt_xlate_add(xl, "mark and 0x%x xor 0x%x ", ~info->mask,
+			     info->mark);
+
+	return 1;
+}
+
+static int MARK_xlate(struct xt_xlate *xl,
+		      const struct xt_xlate_tg_params *params)
+{
+	const struct xt_mark_target_info_v1 *markinfo =
+		(const struct xt_mark_target_info_v1 *)params->target->data;
+
+	xt_xlate_add(xl, "meta mark set ");
+
+	switch(markinfo->mode) {
+	case XT_MARK_SET:
+		xt_xlate_add(xl, "0x%x ", (uint32_t)markinfo->mark);
+		break;
+	case XT_MARK_AND:
+		xt_xlate_add(xl, "mark and 0x%x ", (uint32_t)markinfo->mark);
+		break;
+	case XT_MARK_OR:
+		xt_xlate_add(xl, "mark or 0x%x ", (uint32_t)markinfo->mark);
+		break;
+	}
+
+	return 1;
+}
+
+static struct xtables_target mark_tg_reg[] = {
+	{
+		.family        = NFPROTO_UNSPEC,
+		.name          = "MARK-EXTEND",
+		.version       = XTABLES_VERSION,
+		.revision      = 0,
+		.size          = XT_ALIGN(sizeof(struct xt_mark_target_info)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_mark_target_info)),
+		.help          = MARK_help,
+		.print         = MARK_print_v0,
+		.save          = MARK_save_v0,
+		.x6_parse      = MARK_parse_v0,
+		.x6_fcheck     = MARK_check,
+		.x6_options    = MARK_opts,
+	},
+	{
+		.family        = NFPROTO_IPV4,
+		.name          = "MARK-EXTEND",
+		.version       = XTABLES_VERSION,
+		.revision      = 1,
+		.size          = XT_ALIGN(sizeof(struct xt_mark_target_info_v1)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_mark_target_info_v1)),
+		.help          = MARK_help,
+		.print         = MARK_print_v1,
+		.save          = MARK_save_v1,
+		.x6_parse      = MARK_parse_v1,
+		.x6_fcheck     = MARK_check,
+		.x6_options    = MARK_opts,
+		.xlate	       = MARK_xlate,
+	},
+	{
+		.version       = XTABLES_VERSION,
+		.name          = "MARK-EXTEND",
+		.revision      = 2,
+		.family        = NFPROTO_UNSPEC,
+		.size          = XT_ALIGN(sizeof(struct xt_mark_tginfo2)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_mark_tginfo2)),
+		.help          = mark_tg_help,
+		.print         = mark_tg_print,
+		.save          = mark_tg_save,
+		.x6_parse      = mark_tg_parse,
+		.x6_fcheck     = mark_tg_check,
+		.x6_options    = mark_tg_opts,
+		.xlate	       = mark_tg_xlate,
+	},
+	{
+		.version       = XTABLES_VERSION,
+		.name          = "MARK-EXTEND",
+		.revision      = 2,
+		.family        = NFPROTO_ARP,
+		.size          = XT_ALIGN(sizeof(struct xt_mark_tginfo2)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_mark_tginfo2)),
+		.help          = mark_tg_help,
+		.print         = mark_tg_arp_print,
+		.save          = mark_tg_arp_save,
+		.parse         = mark_tg_arp_parse,
+		.extra_opts    = mark_tg_arp_opts,
+	},
+};
+
+void _init(void)
+{
+	xtables_register_targets(mark_tg_reg, ARRAY_SIZE(mark_tg_reg));
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_mscs.c iptables-1.8.9/extensions/libxt_mscs.c
--- orig_iptables-1.8.9/extensions/libxt_mscs.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_mscs.c	2023-02-01 14:39:50.253958228 +0800
@@ -0,0 +1,94 @@
+#include <stdbool.h>
+#include <stdio.h>
+#include <xtables.h>
+#include <linux/netfilter/xt_mscs.h>
+
+enum {
+       O_BITMAP = 0,
+       O_LIMIT,
+       O_GLOBAL,
+};
+
+static void mscs_mt_help(void)
+{
+       printf(
+"mscs match options:\n"
+"    --up-bitmap value  Match upstream traffic with priority present in UP bitmap\n"
+"    --up-limit value   Limit downstream priority when upstream matched\n"
+"    --global           Global rule\n");
+}
+
+static const struct xt_option_entry mscs_mt_opts[] = {
+       {.name = "up-bitmap",  .id = O_BITMAP,.type = XTTYPE_UINT8, },
+       {.name = "up-limit",   .id = O_LIMIT, .type = XTTYPE_UINT8, },
+       {.name = "global",     .id = O_GLOBAL,.type = XTTYPE_NONE,  },
+       XTOPT_TABLEEND,
+};
+
+static void mscs_mt_parse(struct xt_option_call *cb)
+{
+       struct xt_mscs_mtinfo *info = cb->data;
+
+       xtables_option_parse(cb);
+       switch (cb->entry->id) {
+       case O_BITMAP:  info->is_global = 0; info->up_bitmap = cb->val.u8; break;
+       case O_LIMIT:   info->is_global = 0; info->up_limit = cb->val.u8; break;
+       case O_GLOBAL:  info->is_global = 1; break;
+       }
+}
+
+static void
+mscs_mt_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+       const struct xt_mscs_mtinfo *info = (const void *)match->data;
+
+    printf(" mscs ");
+    if (info->is_global)    printf("global");
+    else                    printf("up-bitmap 0x%02x up-limit %d", info->up_bitmap, info->up_limit);
+}
+
+static void mscs_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+       const struct xt_mscs_mtinfo *info = (const void *)match->data;
+
+    if (info->is_global)    printf(" --global");
+    else                    printf(" --up-bitmap 0x%02x --up-limit %d", info->up_bitmap, info->up_limit);
+}
+
+static void mscs_mt_check(struct xt_fcheck_call *cb)
+{
+       if (cb->xflags == 0)
+               xtables_error(PARAMETER_PROBLEM,
+                       "mscs match: Parameter --global or --up-bitmap is required");
+}
+
+static int mscs_mt_xlate(struct xt_xlate *xl,
+                        const struct xt_xlate_mt_params *params)
+{
+       const struct xt_mscs_mtinfo *info = (const void *)params->match->data;
+
+    if (info->is_global)    xt_xlate_add(xl, " global");
+    else                    xt_xlate_add(xl, " up-bitmap 0x%02x up-limit %d", info->up_bitmap, info->up_limit);
+
+       return 1;
+}
+
+static struct xtables_match mscs_mt_reg = {
+       .version       = XTABLES_VERSION,
+       .name          = "mscs",
+       .family        = NFPROTO_UNSPEC,
+       .size          = XT_ALIGN(sizeof(struct xt_mscs_mtinfo)),
+       .userspacesize = XT_ALIGN(sizeof(struct xt_mscs_mtinfo)),
+       .help          = mscs_mt_help,
+       .print         = mscs_mt_print,
+       .save          = mscs_mt_save,
+       .x6_parse      = mscs_mt_parse,
+       .x6_fcheck     = mscs_mt_check,
+       .x6_options    = mscs_mt_opts,
+       .xlate         = mscs_mt_xlate,
+};
+
+void _init(void)
+{
+       xtables_register_match(&mscs_mt_reg);
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_FSMARK.c iptables-1.8.9/extensions/libxt_FSMARK.c
--- orig_iptables-1.8.9/extensions/libxt_FSMARK.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_FSMARK.c	2023-06-07 14:39:50.253958228 +0800
@@ -0,0 +1,93 @@
+#include <stdio.h>
+#include <xtables.h>
+#include <linux/netfilter/xt_FSMARK.h>
+
+enum {
+	O_ID = 0,
+};
+
+static void FSMARK_help(void)
+{
+	printf(
+"FSMARK target options:\n"
+"    --id val                   mandatory, specify flow stats query ID to use\n");
+}
+
+static const struct xt_option_entry FSMARK_opts[] = {
+	{.name = "id",      .id = O_ID,      .type = XTTYPE_UINT8},
+	XTOPT_TABLEEND,
+};
+
+static void FSMARK_init(struct xt_entry_target *t)
+{
+	struct xt_fsmark_tginfo *info = (void *)t->data;
+
+	info->flags = 0;
+}
+
+static void FSMARK_parse(struct xt_option_call *cb)
+{
+	struct xt_fsmark_tginfo *info = cb->data;
+
+	xtables_option_parse(cb);
+	switch (cb->entry->id) {
+	case O_ID:
+	    if (cb->val.u8 >= MAX_NF_FSMARK_QUERIES)
+	        xtables_error(PARAMETER_PROBLEM, "query id %d valid range is (0 .. %d)", cb->val.u8, MAX_NF_FSMARK_QUERIES-1);
+	    else {
+            info->id = cb->val.u8;
+	        info->flags |= XT_FSMARK_VALID_ID;
+	    }
+    	break;
+	}
+}
+
+static void
+FSMARK_print(const void *ip, const struct xt_entry_target *t, int numeric)
+{
+	const struct xt_fsmark_tginfo *info = (void *)t->data;
+
+	printf(" FSMARK");
+	if (info->flags & XT_FSMARK_VALID_ID)    
+	    printf(" id %d", info->id);
+}
+
+static void FSMARK_save(const void *ip, const struct xt_entry_target *t)
+{
+	const struct xt_fsmark_tginfo *info = (void *)t->data;
+
+	if (info->flags & XT_FSMARK_VALID_ID)    
+	    printf(" --id %d", info->id);
+}
+
+static int FSMARK_xlate(struct xt_xlate *xl,
+		     const struct xt_xlate_tg_params *params)
+{
+	const struct xt_fsmark_tginfo *info = (void *)params->target->data;
+
+	if (info->flags & XT_FSMARK_VALID_ID)    
+	    xt_xlate_add(xl, "id %d", info->id);
+
+	return 1;
+}
+
+static struct xtables_target fsmark_tg = {
+	.family		= NFPROTO_UNSPEC,
+	.name		= "FSMARK",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct xt_fsmark_tginfo)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_fsmark_tginfo)),
+	.help		= FSMARK_help,
+	.init		= FSMARK_init,
+	.print		= FSMARK_print,
+	.save		= FSMARK_save,
+	.x6_parse	= FSMARK_parse,
+	.x6_options	= FSMARK_opts,
+	.xlate		= FSMARK_xlate,
+};
+
+void
+_init(void)
+{
+	xtables_register_target(&fsmark_tg);
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_NAT.c iptables-1.8.9/extensions/libxt_NAT.c
--- orig_iptables-1.8.9/extensions/libxt_NAT.c	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_NAT.c	2023-02-01 14:42:21.154076760 +0800
@@ -40,6 +40,7 @@
 	O_TO_PORTS,
 	O_RANDOM,
 	O_RANDOM_FULLY,
+	O_MODE,
 	O_PERSISTENT,
 };
 
@@ -61,7 +62,9 @@
 " --random\n"
 "				Randomize source port.\n"
 " --random-fully\n"
-"				Fully randomize source port.\n");
+"				Fully randomize source port.\n"
+" --mode <fullcone|symmetric>\n"
+"				NAT mode.\n");
 }
 
 static void DNAT_help(void)
@@ -104,6 +107,7 @@
 	{.name = "to-ports", .id = O_TO_PORTS, .type = XTTYPE_STRING},
 	{.name = "random", .id = O_RANDOM, .type = XTTYPE_NONE},
 	{.name = "random-fully", .id = O_RANDOM_FULLY, .type = XTTYPE_NONE},
+	{.name = "mode", .id = O_MODE, .type = XTTYPE_STRING},	
 	XTOPT_TABLEEND,
 };
 
@@ -262,6 +266,9 @@
 		      proto == IPPROTO_DCCP ||
 		      proto == IPPROTO_ICMP;
 
+	/* Borrow this field as mode value. The default is symmetric */
+	struct nf_nat_ipv4_multi_range_compat *mr = cb->data; mr->range[0].min_ip = 0;
+
 	xtables_option_parse(cb);
 	switch (cb->entry->id) {
 	case O_TO_DEST:
@@ -280,6 +287,15 @@
 	case O_RANDOM_FULLY:
 		range->flags |= NF_NAT_RANGE_PROTO_RANDOM_FULLY;
 		break;
+	case O_MODE:
+		if (strcasecmp(cb->arg, "fullcone") == 0)
+			mr->range[0].min_ip = 1;
+		else if (strcasecmp(cb->arg, "symmetric") == 0)
+			mr->range[0].min_ip = 0;
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "Unknown mode %s", cb->arg);
+      		break;		
 	}
 }
 
@@ -394,10 +410,13 @@
 	return buf;
 }
 
-static void __NAT_print(const struct nf_nat_range2 *r, int family,
+static void __NAT_print(const struct xt_entry_target *target, const struct nf_nat_range2 *r, int family,
 			const char *rangeopt, const char *flag_pfx,
 			bool skip_colon)
 {
+	const struct nf_nat_ipv4_multi_range_compat *mr = (const void *)target->data;
+	const struct nf_nat_ipv4_range *r1 = &mr->range[0];
+
 	char *range_str = sprint_range(r, family);
 
 	if (strlen(range_str)) {
@@ -409,6 +428,8 @@
 		printf(" %srandom", flag_pfx);
 	if (r->flags & NF_NAT_RANGE_PROTO_RANDOM_FULLY)
 		printf(" %srandom-fully", flag_pfx);
+	if (r1->min_ip == 1)
+		printf("mode: fullcone ");		
 	if (r->flags & NF_NAT_RANGE_PERSISTENT)
 		printf(" %spersistent", flag_pfx);
 }
@@ -449,13 +470,13 @@
 {                                                                              \
 	struct nf_nat_range2 range = converter(target->data);                  \
 	                                                                       \
-	__NAT_print(&range, family, print_rangeopt, "", skip_colon);           \
+	__NAT_print(target, &range, family, print_rangeopt, "", skip_colon);           \
 }                                                                              \
 static void name##_save(const void *ip, const struct xt_entry_target *target)  \
 {                                                                              \
 	struct nf_nat_range2 range = converter(target->data);                  \
 	                                                                       \
-	__NAT_print(&range, family, save_rangeopt, "--", skip_colon);          \
+	__NAT_print(target, &range, family, save_rangeopt, "--", skip_colon);          \
 }                                                                              \
 static int name##_xlate(struct xt_xlate *xl,                                   \
 			const struct xt_xlate_tg_params *params)               \
diff -urN orig_iptables-1.8.9/extensions/libxt_scs.c iptables-1.8.9/extensions/libxt_scs.c
--- orig_iptables-1.8.9/extensions/libxt_scs.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_scs.c	2023-02-01 14:39:50.257958549 +0800
@@ -0,0 +1,152 @@
+#include <stdio.h>
+#include <xtables.h>
+#include <linux/netfilter/xt_scs.h>
+
+enum {
+	O_ESPSPI = 0,
+	O_UP_SET,
+	O_IS_UP_SET,
+	O_UDPESP_PORT,
+};
+
+static void scs_help(void)
+{
+	printf(
+"scs match options:\n"
+"    [!] --espspi spi[/mask]	match spi (mask)\n"
+"        --udpesp <value>       match UDP L4 ports\n"
+"    [!] --up-is-set            match user priority already set\n"
+"        --up-set <value>       override user priority\n");
+}
+
+static const struct xt_option_entry scs_opts[] = {
+	{.name = "espspi",    .id = O_ESPSPI,    .type = XTTYPE_MARKMASK32, .flags = XTOPT_INVERT},
+	{.name = "udpesp",    .id = O_UDPESP_PORT,.type= XTTYPE_UINT16, },
+	{.name = "up-is-set", .id = O_IS_UP_SET, .type = XTTYPE_NONE, .flags = XTOPT_INVERT},
+	{.name = "up-set",    .id = O_UP_SET,    .type = XTTYPE_UINT8, },
+	XTOPT_TABLEEND,
+};
+
+static void scs_init(struct xt_entry_match *m)
+{
+	struct xt_scs_mtinfo *info = (void *)m->data;
+
+	info->spis[1] = ~0U;
+}
+
+static void scs_parse(struct xt_option_call *cb)
+{
+	struct xt_scs_mtinfo *info = cb->data;
+
+	xtables_option_parse(cb);
+	switch (cb->entry->id) {
+	case O_ESPSPI:  
+	    info->invflags |= XT_SCS_VALID_SPIS;
+    	if (cb->invert) info->invflags |= XT_SCS_INV_SPI;
+        info->spis[0] = cb->val.mark; info->spis[1] = cb->val.mask;
+    	break;
+	case O_IS_UP_SET: 
+	    info->invflags |= XT_SCS_VALID_UP_OVRD;
+    	if (cb->invert) info->invflags |= XT_SCS_INV_UP_OVRD;
+    	break;
+    case O_UP_SET:  
+        info->invflags |= XT_SCS_VALID_UP_VAL;
+        info->up_val = cb->val.u8;
+        break; 
+    case O_UDPESP_PORT:  
+        info->invflags |= XT_SCS_VALID_UDPESP_L4P;
+        info->udpesp_port = cb->val.u16;
+        break; 
+	}
+}
+
+static void
+print_spis(const char *name, uint32_t val, uint32_t mask,
+	    int invert)
+{
+	const char *inv = invert ? "!" : "";
+
+    if (mask == ~0U)
+        printf(" %s:%s%x", name, inv, val);
+    else
+        printf(" %s:%s%x/%x", name, inv, val, mask);
+}
+
+static void
+scs_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_scs_mtinfo *info = (struct xt_scs_mtinfo *)match->data;
+
+	printf(" scs");
+	if (info->invflags & XT_SCS_VALID_UP_OVRD)    
+	    printf(" %s up-is-set", (info->invflags & XT_SCS_INV_UP_OVRD) ? "!":"");
+	if (info->invflags & XT_SCS_VALID_SPIS)    
+	    print_spis("spi", info->spis[0], info->spis[1], info->invflags & XT_SCS_INV_SPI);
+	if (info->invflags & XT_SCS_VALID_UP_VAL)
+	    printf(" up-set %u", info->up_val);
+	if (info->invflags & XT_SCS_VALID_UDPESP_L4P)
+	    printf(" udpesp %u", info->udpesp_port);
+}
+
+static void scs_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_scs_mtinfo *info = (struct xt_scs_mtinfo *)match->data;
+
+	if (info->invflags & XT_SCS_VALID_SPIS) {
+		printf("%s --espspi ",
+			(info->invflags & XT_SCS_INV_SPI) ? " !" : "");
+        if (info->spis[1] == ~0U)
+			printf("%x", info->spis[0]);
+	    else
+			printf("%x/%x", info->spis[0], info->spis[1]);
+	}
+	if (info->invflags & XT_SCS_VALID_UP_OVRD)    
+	    printf(" %s --up-is-set", (info->invflags & XT_SCS_INV_UP_OVRD) ? "!":"");
+	if (info->invflags & XT_SCS_VALID_UP_VAL)
+	    printf(" --up-set %u", info->up_val);
+	if (info->invflags & XT_SCS_VALID_UDPESP_L4P)
+	    printf(" --udpesp %u", info->udpesp_port);
+}
+
+static int scs_xlate(struct xt_xlate *xl,
+		     const struct xt_xlate_mt_params *params)
+{
+	const struct xt_scs_mtinfo *info = (struct xt_scs_mtinfo *)params->match->data;
+
+	if (info->invflags & XT_SCS_VALID_SPIS) {
+		xt_xlate_add(xl, " scs spi%s", (info->invflags & XT_SCS_INV_SPI) ? " !=" : "");
+        if (info->spis[1] == ~0U)
+			xt_xlate_add(xl, " %x", info->spis[0]);
+		else
+			xt_xlate_add(xl, " %x/%x", info->spis[0], info->spis[1]);
+	}
+	if (info->invflags & XT_SCS_VALID_UP_OVRD)    
+	    xt_xlate_add(" %s up-is-set", (info->invflags & XT_SCS_INV_UP_OVRD) ? "!":"");
+	if (info->invflags & XT_SCS_VALID_UP_VAL)
+	    xt_xlate_add(" up-set %u", info->up_val);
+	if (info->invflags & XT_SCS_VALID_UDPESP_L4P)
+	    xt_xlate_add(" udpesp %u", info->udpesp_port);
+
+	return 1;
+}
+
+static struct xtables_match scs_match = {
+	.family		= NFPROTO_UNSPEC,
+	.name		= "scs",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct xt_scs_mtinfo)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_scs_mtinfo)),
+	.help		= scs_help,
+	.init		= scs_init,
+	.print		= scs_print,
+	.save		= scs_save,
+	.x6_parse	= scs_parse,
+	.x6_options	= scs_opts,
+	.xlate		= scs_xlate,
+};
+
+void
+_init(void)
+{
+	xtables_register_match(&scs_match);
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_SKIPLOG.c iptables-1.8.9/extensions/libxt_SKIPLOG.c
--- orig_iptables-1.8.9/extensions/libxt_SKIPLOG.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_SKIPLOG.c	2023-02-01 14:39:50.249957907 +0800
@@ -0,0 +1,51 @@
+/* Shared library add-on to iptables to add SKIPLOG target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+
+/* Function which prints out usage message. */
+static void SKIPLOG_help(void)
+{
+	printf(
+"SKIPLOG target v%s takes no options\n",
+XTABLES_VERSION);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+SKIPLOG_parse(int c, char **argv, int invert, unsigned int *flags,
+              const void *entry, struct xt_entry_target **target)
+{
+	return 0;
+}
+
+static struct xtables_target skiplog_target = {
+	.family		= AF_INET,
+	.name		= "SKIPLOG",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(0),
+	.userspacesize	= XT_ALIGN(0),
+	.help		= SKIPLOG_help,
+	.parse		= SKIPLOG_parse,
+};
+
+static struct xtables_target skiplog_target6 = {
+	.family		= AF_INET6,
+	.name		= "SKIPLOG",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(0),
+	.userspacesize	= XT_ALIGN(0),
+	.help		= SKIPLOG_help,
+	.parse		= SKIPLOG_parse,
+};
+
+void _init(void)
+{
+	xtables_register_target(&skiplog_target);
+	xtables_register_target(&skiplog_target6);
+}
diff -urN orig_iptables-1.8.9/extensions/libxt_tcp.c iptables-1.8.9/extensions/libxt_tcp.c
--- orig_iptables-1.8.9/extensions/libxt_tcp.c	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/extensions/libxt_tcp.c	2023-02-01 14:39:50.253958228 +0800
@@ -23,7 +23,9 @@
 "[!] --destination-port port[:port]\n"
 " --dport ...\n"
 "				match destination port(s)\n"
-"[!] --tcp-option number        match if TCP option set\n");
+"[!] --tcp-option number        match if TCP option set\n"
+"[!] --tcp-pureack              match when only ACK flag set and\n"
+"                               payload length is zero\n");
 }
 
 static const struct option tcp_opts[] = {
@@ -34,6 +36,7 @@
 	{.name = "syn",              .has_arg = false, .val = '3'},
 	{.name = "tcp-flags",        .has_arg = true,  .val = '4'},
 	{.name = "tcp-option",       .has_arg = true,  .val = '5'},
+	{.name = "tcp-pureack",      .has_arg = false, .val = '6'},
 	XT_GETOPT_TABLEEND,
 };
 
@@ -168,7 +171,7 @@
 		if (*flags & TCP_FLAGS)
 			xtables_error(PARAMETER_PROBLEM,
 				   "Only one of `--syn' or `--tcp-flags' "
-				   " allowed");
+				   " or --tcp-pureack allowed");
 		parse_tcp_flags(tcpinfo, "SYN,RST,ACK,FIN", "SYN", invert);
 		*flags |= TCP_FLAGS;
 		break;
@@ -177,7 +180,7 @@
 		if (*flags & TCP_FLAGS)
 			xtables_error(PARAMETER_PROBLEM,
 				   "Only one of `--syn' or `--tcp-flags' "
-				   " allowed");
+				   " or --tcp-pureack allowed");
 		if (!argv[optind]
 		    || argv[optind][0] == '-' || argv[optind][0] == '!')
 			xtables_error(PARAMETER_PROBLEM,
@@ -198,6 +201,16 @@
 			tcpinfo->invflags |= XT_TCP_INV_OPTION;
 		*flags |= TCP_OPTION;
 		break;
+
+	case '6':
+		if (*flags & TCP_FLAGS)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Only one of `--syn' or `--tcp-flags' "
+				   " or --tcp-pureack allowed");
+		parse_tcp_flags(tcpinfo, "SYN,RST,ACK,FIN", "ACK", invert);
+		tcpinfo->pure_ack = 1;
+		*flags |= TCP_FLAGS;
+		break;
 	}
 
 	return 1;
@@ -307,6 +320,8 @@
 	print_flags(tcp->flg_mask, tcp->flg_cmp,
 		    tcp->invflags & XT_TCP_INV_FLAGS,
 		    numeric);
+    if (tcp->pure_ack)
+		printf(" pure ACK");
 	if (tcp->invflags & ~XT_TCP_INV_MASK)
 		printf(" Unknown invflags: 0x%X",
 		       tcp->invflags & ~XT_TCP_INV_MASK);
@@ -360,6 +375,12 @@
 		printf(" ");
 		print_tcpf(tcpinfo->flg_cmp);
 	}
+
+	if (tcpinfo->pure_ack) {
+		if (tcpinfo->invflags & XT_TCP_INV_FLAGS)
+			printf(" !");
+		printf(" --tcp-pureack ");
+	}
 }
 
 static const struct tcp_flag_names tcp_flag_names_xlate[] = {
diff -urN orig_iptables-1.8.9/include/linux/netfilter/nf_conntrack_tuple_common.h iptables-1.8.9/include/linux/netfilter/nf_conntrack_tuple_common.h
--- orig_iptables-1.8.9/include/linux/netfilter/nf_conntrack_tuple_common.h	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/nf_conntrack_tuple_common.h	2023-02-01 14:39:50.253958228 +0800
@@ -32,6 +32,11 @@
 	struct {
 		__be16 key;	/* GRE key is 32bit, PPtP only uses 16bit */
 	} gre;
+#ifdef SUPPORT_IPSEC_PASSTHROUGH
+	struct {
+		__be16 spi;
+	} esp;
+#endif
 };
 
 #define CTINFO2DIR(ctinfo) ((ctinfo) >= IP_CT_IS_REPLY ? IP_CT_DIR_REPLY : IP_CT_DIR_ORIGINAL)
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_blog.h iptables-1.8.9/include/linux/netfilter/xt_blog.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_blog.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_blog.h	2023-02-01 14:39:50.253958228 +0800
@@ -0,0 +1,11 @@
+#ifndef _XT_BLOG_H
+#define _XT_BLOG_H
+
+#include <linux/types.h>
+
+struct xt_blog {
+    __u8 tcp_pure_ack;
+    __u8 invert;
+};
+
+#endif /*_XT_BLOG_H*/
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_connlimit.h iptables-1.8.9/include/linux/netfilter/xt_connlimit.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_connlimit.h	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_connlimit.h	2023-02-01 14:39:50.253958228 +0800
@@ -8,6 +8,7 @@
 enum {
 	XT_CONNLIMIT_INVERT = 1 << 0,
 	XT_CONNLIMIT_DADDR  = 1 << 1,
+	XT_CONNLIMIT_DADDR_DPORT  = 1 << 2,
 };
 
 struct xt_connlimit_info {
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_flowlabel.h iptables-1.8.9/include/linux/netfilter/xt_flowlabel.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_flowlabel.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_flowlabel.h	2023-02-01 14:39:50.253958228 +0800
@@ -0,0 +1,35 @@
+#ifndef _XT_FLOWLABEL_H
+#define _XT_FLOWLABEL_H
+
+/*
+ * Shared library add-on to iptables to add IPv6 flowlabel match support
+ *
+ * BRCM, Feb, 1. 2019.
+ */
+
+#include <byteswap.h>
+
+
+#if defined(__LITTLE_ENDIAN) && (__BYTE_ORDER == __LITTLE_ENDIAN)
+#define be32_to_cpu(x) bswap_32(x)
+#define cpu_to_be32(x) bswap_32(x)
+
+#elif defined(__BIG_ENDIAN) && (__BYTE_ORDER == __BIG_ENDIAN)
+#define be32_to_cpu(x) (x)
+#define cpu_to_be32(x) (x)
+
+#else
+#error "You must define __BYTE_ORDER to be __LITTLE_ENDIAN or __BIG_ENDIAN."
+#endif // defined(__LITTLE_ENDIAN) && (__BYTE_ORDER == __LITTLE_ENDIAN)
+
+
+#define XT_FLOWLABEL_MAX	0x000FFFFF
+
+/* match info */
+struct xt_flowlabel_info {
+	__be32 flowlabel;
+	__u8 invert;
+};
+
+#endif /*_XT_FLOWLABEL_H*/
+
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_mac_extend.h iptables-1.8.9/include/linux/netfilter/xt_mac_extend.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_mac_extend.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_mac_extend.h	2023-02-01 14:39:50.253958228 +0800
@@ -0,0 +1,14 @@
+#ifndef _XT_MAC_EXTEND_H
+#define _XT_MAC_EXTEND_H
+
+/* extend from xt_mac.h for MAC address extend match operations,
+ * i.e, MAC/mask. 
+ * BRCM, Jan, 31. 2019.
+ */
+
+struct xt_mac_info_extend {
+    unsigned char srcaddr[ETH_ALEN];
+    unsigned char msk[ETH_ALEN];
+    int invert;
+};
+#endif /*_XT_MAC_EXTEND_H*/
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_mscs.h iptables-1.8.9/include/linux/netfilter/xt_mscs.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_mscs.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_mscs.h	2023-02-01 14:39:50.257958549 +0800
@@ -0,0 +1,15 @@
+#ifndef _XT_MSCS_H
+#define _XT_MSCS_H
+
+#include <linux/types.h>
+
+struct xt_mscs_mtinfo {
+    __u8 up_bitmap;
+    __u8 up_limit;
+    __u8 is_global;
+
+    /* Used internally by the kernel */
+    void *data __attribute__((aligned(8)));
+};
+
+#endif /*_XT_MSCS_H*/
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_scs.h iptables-1.8.9/include/linux/netfilter/xt_scs.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_scs.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_scs.h	2023-02-01 14:39:50.257958549 +0800
@@ -0,0 +1,25 @@
+#ifndef _XT_SCS_H
+#define _XT_SCS_H
+
+#include <linux/types.h>
+
+struct xt_scs_mtinfo {
+    __u32 spis[2];  /* Security Parameter Index */
+    __u16 udpesp_port;
+    __u8  invflags; /* Inverse flags */
+    __u8  up_val;
+
+    /* Used internally by the kernel */
+    void *data __attribute__((aligned(8)));
+};
+
+/* Values for "invflags" field in struct xt_scs. */
+#define XT_SCS_INV_SPI	    0x01	/* Invert the sense of spi. */
+#define XT_SCS_INV_UP_OVRD  0x02
+#define XT_SCS_INV_MASK	    0x07	/* All possible flags. */
+#define XT_SCS_VALID_UDPESP_L4P 0x08
+#define XT_SCS_VALID_SPIS       0x10
+#define XT_SCS_VALID_UP_OVRD    0x20
+#define XT_SCS_VALID_UP_VAL     0x80
+
+#endif /*_XT_SCS_H*/
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_FSMARK.h iptables-1.8.9/include/linux/netfilter/xt_FSMARK.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_FSMARK.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_FSMARKs.h	2023-06-07 14:39:50.257958549 +0800
@@ -0,0 +1,15 @@
+#ifndef _XT_FSMARK_H
+#define _XT_FSMARK_H
+
+#include <linux/types.h>
+
+#define MAX_NF_FSMARK_QUERIES         128    // FSMARK query ID 0..127
+
+struct xt_fsmark_tginfo {
+    __u8    id;
+    __u8    flags;
+};
+
+#define XT_FSMARK_VALID_ID      0x01
+
+#endif /*_XT_FSMARK_H*/
diff -urN orig_iptables-1.8.9/include/linux/netfilter/xt_tcpudp.h iptables-1.8.9/include/linux/netfilter/xt_tcpudp.h
--- orig_iptables-1.8.9/include/linux/netfilter/xt_tcpudp.h	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/include/linux/netfilter/xt_tcpudp.h	2023-02-01 14:39:50.253958228 +0800
@@ -11,6 +11,7 @@
 	__u8 flg_mask;			/* TCP flags mask byte */
 	__u8 flg_cmp;			/* TCP flags compare byte */
 	__u8 invflags;			/* Inverse flags */
+	__u8 pure_ack;			/* Pure ACK packet */
 };
 
 /* Values for "inv" field in struct ipt_tcp. */
diff -urN orig_iptables-1.8.9/iptables/xshared.h iptables-1.8.9/iptables/xshared.h
--- orig_iptables-1.8.9/iptables/xshared.h	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/iptables/xshared.h	2023-02-01 14:39:50.257958549 +0800
@@ -4,6 +4,7 @@
 #include <limits.h>
 #include <stdbool.h>
 #include <stdint.h>
+#include <sys/types.h>
 #include <netinet/in.h>
 #include <net/if.h>
 #include <linux/netfilter_arp/arp_tables.h>
diff -urN orig_iptables-1.8.9/libxtables/xtoptions.c iptables-1.8.9/libxtables/xtoptions.c
--- orig_iptables-1.8.9/libxtables/xtoptions.c	2023-01-12 18:27:35.000000000 +0800
+++ iptables-1.8.9/libxtables/xtoptions.c	2023-02-01 14:39:50.253958228 +0800
@@ -544,6 +544,10 @@
 	struct addrinfo *res = NULL, *p;
 	int ret;
 
+   /* brcm */
+   if ((ret = strtol(name, NULL, 0)) > 0)
+      return ret;
+   
 	ret = getaddrinfo(NULL, name, NULL, &res);
 	if (ret != 0)
 		return -1;
