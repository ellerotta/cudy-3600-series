--- htpdate.c	2023-02-07 10:43:45.401381570 +0800
+++ htpdate-1.3.7/htpdate.c	2023-02-07 11:10:25.776410340 +0800
@@ -83,6 +83,7 @@
 #define BUFFERSIZE               8192
 #define PRINTBUFFERSIZE          BUFFERSIZE
 #define PLUME_EPOCH             1451602800      /* 01/01/2016   */
+#define SOCK_TIMEOUT_MS         2000            /* socket ops timeout   */
 
 #define sign(x) (x < 0 ? (-1) : 1)
 
@@ -213,18 +214,118 @@ static long long getoffset(char remote_t
 }
 
 
-static int sendHEAD(int server_s, char *headrequest, char *buffer) {
-    int ret = send(server_s, headrequest, strlen(headrequest), 0);
+/*
+ * Non-blocking implementation of send
+ * After intensive testing it looks like send never blocks
+ */
+int sendsock(int sock, void * buff, size_t len,  int timeout)
+{
+	int rc = -1;
+	struct pollfd pfd[1];
+
+	pfd[0].fd = sock;
+	pfd[0].events = POLLOUT;
+
+	rc = poll(pfd, sizeof(pfd) / sizeof(pfd[0]), timeout);
+
+    switch(rc)
+	{
+		/* Wait on write to complete */
+		case 0:
+            if (debug)
+			    printlog(0, "Timedout.\n");
+			rc = -1;
+			break;
+
+		case -1:
+            if (debug)
+			    printlog(1, "Error write poll\n");
+			break;
+
+		default:
+			if (pfd[0].events & POLLERR)
+			{
+                if (debug)
+				    printlog(1, "poll() returned POLERR.\n");
+			}
+
+			if ((pfd[0].events & POLLOUT))
+			{
+				rc = send(sock, buff, len, 0);
+			}
+			break;
+	}
+
+	return rc;
+}
+
+
+/* non-blocking recv, avoid waiting indefinitely in case uplink
+ * breaks between opening the socket and receiving
+ */
+int recvsock(int sock, void * buff, size_t len,  int timeout)
+{
+	int rc = -1;
+	struct pollfd pfd[1];
+
+	pfd[0].fd = sock;
+	pfd[0].events = POLLIN;
 
+	rc = poll(pfd, sizeof(pfd) / sizeof(pfd[0]), timeout);
+
+    switch(rc)
+	{
+		/* Wait on write to complete */
+		case 0:
+            if (debug)
+			    printlog(0, "Timedout.\n");
+			rc = -1;
+			break;
+
+		case -1:
+            if (debug)
+			    printlog(1, "Error read poll\n");
+			break;
+
+		default:
+			if (pfd[0].events & POLLERR)
+			{
+                if (debug)
+				    printlog(1, "poll() returned POLERR.\n");
+			}
+
+			if ((pfd[0].events & POLLIN))
+			{
+				rc = recv(sock, buff, len, 0);
+			}
+			break;
+	}
+
+	return rc;
+}
+
+
+static int sendHEAD(int server_s, char *headrequest, char *buffer, int *error) {
+    int ret = sendsock(server_s, headrequest, strlen(headrequest), SOCK_TIMEOUT_MS);
+    
     if (ret < 0) {
         printlog(1, "Error sending");
+        *error = 1;
+        close(server_s);
         return -1;
     }
 
     /* Receive data from the web server
        The return code from recv() is the number of bytes received
     */
-    ret = recv(server_s, buffer, BUFFERSIZE - 1, 0) > 0;
+    ret = recvsock(server_s, buffer, BUFFERSIZE - 1, SOCK_TIMEOUT_MS) > 0;
+
+    if (ret == -1) {
+        printlog(1, "error reading server");
+        close( server_s );
+        *error = 1;
+        return -1;
+    }
 
     return ret;
 }
@@ -492,7 +593,7 @@ static double getHTTPdate(
             rc = sendHEADTLS(conn, headrequest, buffer);
         else
         #endif
-            rc = sendHEAD(server_s, headrequest, buffer);
+            rc = sendHEAD(server_s, headrequest, buffer, error);
 
         if (!rc) {
             printlog(1, "error from %s:%s", host, port );
