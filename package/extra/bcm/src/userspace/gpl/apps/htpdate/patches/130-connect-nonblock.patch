--- htpdate.c	2023-02-06 16:18:39.714384312 +0800
+++ htpdate-1.3.7/htpdate.c	2023-02-06 16:35:41.021362950 +0800
@@ -52,6 +52,9 @@
 #include <pwd.h>
 #include <grp.h>
 #include <float.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <poll.h>
 
 #if defined __NetBSD__ || defined __FreeBSD__ || defined __APPLE__
 #define adjtimex ntp_adjtime
@@ -267,6 +270,96 @@ static int proxyCONNECT(
 #endif
 
 
+static int opensock( struct addrinfo *ai )
+{
+    int rc;
+    int sock = -1;
+    struct addrinfo *pai;
+    int serr = -1;
+    socklen_t serr_len = sizeof(serr);
+
+    /* Traverse list of resolved hosts */
+    for (pai = ai; pai != NULL; pai = pai->ai_next)
+    {
+
+
+        sock = socket(pai->ai_family, pai->ai_socktype, pai->ai_protocol);
+        if (sock < 0)
+        {
+
+            goto retry;
+        }
+
+        int flags = fcntl(sock, F_GETFL);
+        if (flags  < 0)
+        {
+            goto retry;
+        }
+
+        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) == -1)
+        {
+            goto retry;
+        }
+
+        rc = connect(sock, pai->ai_addr, pai->ai_addrlen);
+
+        if (rc != 0)
+        {
+            if (errno != EINPROGRESS)
+            {
+                if (debug)
+                    printlog(1, "connect() failed: %s\n", strerror(errno));
+                goto retry;
+            }
+
+            /* Wait on connection */
+            struct pollfd pfd[1];
+
+            pfd[0].fd = sock;
+            pfd[0].events = POLLOUT;
+
+            rc = poll(pfd, sizeof(pfd) / sizeof(pfd[0]), 2000);
+            if (rc == 0)
+            {
+                goto retry;
+            }
+
+            if (pfd[0].events & POLLERR)
+            {
+                goto retry;
+            }
+
+            if (!(pfd[0].events & POLLOUT))
+            {
+                goto retry;
+            }
+
+            rc = getsockopt(sock, SOL_SOCKET, SO_ERROR, &serr, &serr_len);
+            if (rc != 0)
+            {
+                goto retry;
+            }
+
+            if (serr != 0)
+            {
+                goto retry;
+            }
+        }
+
+        break;
+
+retry:
+        if (sock >= 0)
+        {
+            close(sock);
+            sock = -1;
+        }
+    }
+
+    return sock;
+}
+
+
 static double getHTTPdate(
     char *scheme,
     char *host, char *port, char *path,
@@ -332,25 +425,11 @@ static double getHTTPdate(
         url, path, httpversion, host);
 
     /* Loop through the available canonical names */
-    do {
-        server_s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-        if (server_s < 0) {
-            continue;
-        }
-
-        rc = connect(server_s, res->ai_addr, res->ai_addrlen);
-        if (rc) {
-            close(server_s);
-            server_s = -1;
-            continue;
-        }
-
-        break;
-    } while ((res = res->ai_next));
+    server_s = opensock(res);
 
     freeaddrinfo(res);
 
-    if (rc) {
+    if ( server_s < 0 ) {    
         if ( debug )
 	    printlog(1, "%s connection failed", host);
         *error = 1;        
@@ -612,7 +691,7 @@ static int htpdate_plumeepoch( void ) {
     struct timeval  timeofday;
     int pepoch = 0;
 
-	gettimeofday(&timeofday, NULL);
+    gettimeofday(&timeofday, NULL);
 
     if ( timeofday.tv_sec > PLUME_EPOCH )
         pepoch  = 1;
