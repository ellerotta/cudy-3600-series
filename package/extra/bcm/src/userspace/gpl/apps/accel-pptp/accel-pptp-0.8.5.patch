diff -Naur orig_accel-pptp-0.8.5/pppd_plugin/configure accel-pptp-0.8.5/pppd_plugin/configure
--- orig_accel-pptp-0.8.5/pppd_plugin/configure	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pppd_plugin/configure	2022-06-20 16:09:04.870575654 +0800
@@ -19423,35 +19423,14 @@
 
 { echo "$as_me:$LINENO: checking for linux kernel herders" >&5
 echo $ECHO_N "checking for linux kernel herders... $ECHO_C" >&6; }
-if test -n "${KDIR}"; then
-    if test -f ${KDIR}/include/linux/version.h; then
-	header=${KDIR}/include
-    else
-	{ echo "$as_me:$LINENO: result: not found" >&5
-echo "${ECHO_T}not found" >&6; }
-	{ { echo "$as_me:$LINENO: error: Could not find linux kernel headers" >&5
-echo "$as_me: error: Could not find linux kernel headers" >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-else
-    kernel=`uname -r`
-    if test -f /usr/src/linux/include/linux/version.h; then
-	header=/usr/src/linux/include
-    elif test -f /lib/modules/${kernel}/build/include/linux/version.h; then
-	header=/lib/modules/${kernel}/build/include
-    else
-	{ echo "$as_me:$LINENO: result: not found" >&5
-echo "${ECHO_T}not found" >&6; }
-	{ { echo "$as_me:$LINENO: error: Could not find linux kernel headers" >&5
-echo "$as_me: error: Could not find linux kernel headers" >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-fi
+
 VERSION=$(cat ${header/include}Makefile | grep '^VERSION = ' | awk '{print $3}')
 PATCHLEVEL=$(cat ${header/include}Makefile | grep '^PATCHLEVEL = ' | awk '{print $3}')
 SUBLEVEL=$(cat ${header/include}Makefile | grep '^SUBLEVEL = ' | awk '{print $3}')
 EXTRAVERSION=$(cat ${header/include}Makefile | grep '^EXTRAVERSION = ' | awk '{print $3}')
-KERNELVERSION=$VERSION.$PATCHLEVEL.$SUBLEVEL$EXTRAVERSION
+if test "xx$KERNELVERSION" = "xx"; then
+  KERNELVERSION=$VERSION.$PATCHLEVEL.$SUBLEVEL$EXTRAVERSION
+fi
 { echo "$as_me:$LINENO: result: found ($KERNELVERSION at ${header/include})" >&5
 echo "${ECHO_T}found ($KERNELVERSION at ${header/include})" >&6; }
 cat >>confdefs.h <<_ACEOF
@@ -19460,12 +19439,15 @@
 
 
 
-CFLAGS="${CFLAGS} -I. -I${header}"
+#CFLAGS="${CFLAGS} -I. -I${header}" 
+CFLAGS="${CFLAGS} -I. " 
+
+echo    '   configure set PPPD VERSION:               '${pppd}
 
 { echo "$as_me:$LINENO: checking for pppd" >&5
 echo $ECHO_N "checking for pppd... $ECHO_C" >&6; }
-pppd=`which pppd 2>&1`
-if test $? -eq 1; then
+
+if test "xx$pppd" = "xx"; then
     pppd=""
     for path in /usr/sbin /usr/local/sbin /usr/bin /usr/local/bin /sbin; do
 	if test -x ${path}/pppd; then
@@ -19475,14 +19457,17 @@
     done
 fi
 
-if test -z "${pppd}"; then
-    { echo "$as_me:$LINENO: result: not found" >&5
-echo "${ECHO_T}not found" >&6; }
-    { { echo "$as_me:$LINENO: error: Could not find pppd" >&5
-echo "$as_me: error: Could not find pppd" >&2;}
-   { (exit 1); exit 1; }; }
+if test "xx$pppd_ver" = "xx"; then
+  pppd_ver=${pppd}
+else
+  pppd_ver=`${pppd} --version 2>&1 | grep version | sed 's/pppd version //'`
 fi
-pppd_ver=`${pppd} --version 2>&1 | grep version | sed 's/pppd version //'`
+
+# pppd_ver is still null
+if test "xx$pppd_ver" = "xx"; then
+  pppd_ver='2.4.7'
+fi
+
 { echo "$as_me:$LINENO: result: $pppd ($pppd_ver)" >&5
 echo "${ECHO_T}$pppd ($pppd_ver)" >&6; }
 cat >>confdefs.h <<_ACEOF
@@ -20884,4 +20869,3 @@
   $ac_cs_success || { (exit 1); exit 1; }
 fi
 
-

--- orig_accel-pptp-0.8.5/pppd_plugin/src/pptp.c	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pppd_plugin/src/pptp.c	2023-04-19 14:02:27.739431939 +0800
@@ -56,7 +56,7 @@
 
 
 extern char** environ;
-
+extern char ppp_devname[];
 char pppd_version[] = PPPD_VERSION;
 extern int new_style_driver;
 
@@ -113,8 +113,9 @@
 static int pptp_start_server(void)
 {
 	pptp_fd=pptp_sock;
-	sprintf(ppp_devnam,"pptp (%s)",pptp_client);
-
+	sprintf(ppp_devname,"pptp (%s)",pptp_client);
+    use_pptpd_secrets_path = 1;
+    
 	return pptp_fd;
 }
 static int pptp_start_client(void)
@@ -197,8 +198,8 @@
 		error("PPTP: failed to connect PPTP socket (%s)\n",strerror(errno));
 		return -1;
 	}
-
-	sprintf(ppp_devnam,"pptp (%s)",pptp_server);
+    strcpy(ppp_devname, "lo");
+	//sprintf(ppp_devnam,"pptp (%s)",pptp_server);
 
 	return pptp_fd;
 }

diff -urp orig_accel-pptp-0.8.5/pppd_plugin/config.sub accel-pptp-0.8.5/pppd_plugin/config.sub
--- orig_accel-pptp-0.8.5/pppd_plugin/config.sub	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pppd_plugin/config.sub	2017-05-02 10:48:29.721694383 +0800
@@ -238,6 +238,7 @@ case $basic_machine in
 	# Some are omitted here because they have special meanings below.
 	1750a | 580 \
 	| a29k \
+	| aarch64 | aarch64_be \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
@@ -314,6 +315,7 @@ case $basic_machine in
 	# Recognize the basic CPU types with company name.
 	580-* \
 	| a29k-* \
+	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \


--- orig_accel-pptp-0.8.5/pptpd-1.3.3/configure	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/configure	2022-08-04 11:16:00.549595531 +0800
@@ -2243,6 +2243,13 @@
 
 fi
 
+if test "xx$PPTP_FACILITY" = "xx"; then
+  PPTP_FACILITY=LOG_DAEMON
+else
+  echo    'PPTP_FACILITY is :    ' ${PPTP_FACILITY}
+fi
+
+echo    '   Set syslog facility name PPTP_FACILITY = '${PPTP_FACILITY}
 
 { echo "$as_me:$LINENO: checking command line for bcrelay build" >&5
 echo $ECHO_N "checking command line for bcrelay build... $ECHO_C" >&6; }
@@ -6179,38 +6186,15 @@
 
 
 
-{ echo "$as_me:$LINENO: checking for linux kernel herders" >&5
-echo $ECHO_N "checking for linux kernel herders... $ECHO_C" >&6; }
-if test -n "${KDIR}"; then
-	if test -f ${KDIR}/include/linux/version.h; then
-		header=${KDIR}/include
-	else
-		{ echo "$as_me:$LINENO: result: not found" >&5
-echo "${ECHO_T}not found" >&6; }
-		{ { echo "$as_me:$LINENO: error: Could not find linux kernel headers" >&5
-echo "$as_me: error: Could not find linux kernel headers" >&2;}
-   { (exit 1); exit 1; }; }
-	fi
-else
-	kernel=`uname -r`
-	if test -f /usr/src/linux/include/linux/version.h; then
-		header=/usr/src/linux/include
-	elif test -f /lib/modules/${kernel}/build/include/linux/version.h; then
-		header=/lib/modules/${kernel}/build/include
-	else
-		{ echo "$as_me:$LINENO: result: not found" >&5
-echo "${ECHO_T}not found" >&6; }
-		{ { echo "$as_me:$LINENO: error: Could not find linux kernel headers" >&5
-echo "$as_me: error: Could not find linux kernel headers" >&2;}
-   { (exit 1); exit 1; }; }
-	fi
-fi
 
 VERSION=$(cat ${header/include}Makefile | grep '^VERSION = ' | awk '{print $3}')
 PATCHLEVEL=$(cat ${header/include}Makefile | grep '^PATCHLEVEL = ' | awk '{print $3}')
 SUBLEVEL=$(cat ${header/include}Makefile | grep '^SUBLEVEL = ' | awk '{print $3}')
 EXTRAVERSION=$(cat ${header/include}Makefile | grep '^EXTRAVERSION = ' | awk '{print $3}')
-KERNELVERSION=$VERSION.$PATCHLEVEL.$SUBLEVEL$EXTRAVERSION
+if test "xx$KERNELVERSION" = "xx"; then
+  KERNELVERSION=$VERSION.$PATCHLEVEL.$SUBLEVEL$EXTRAVERSION
+fi
+
 cat >>confdefs.h <<_ACEOF
 #define KERNELVERSION "$KERNELVERSION"
 _ACEOF
@@ -6221,11 +6205,12 @@
 CFLAGS="${CFLAGS} -I. -I${header}"
 kernel_headers=${header}
 
+echo    '   configure set PPPD VERSION:               '${pppd}
 
 { echo "$as_me:$LINENO: checking for pppd" >&5
 echo $ECHO_N "checking for pppd... $ECHO_C" >&6; }
-pppd=`which pppd 2>&1`
-if test $? -eq 1; then
+
+if test "xx$pppd" = "xx"; then
 	pppd=""
 	for path in /usr/sbin /usr/local/sbin /usr/bin /usr/local/bin /sbin; do
 		if test -x ${path}/pppd; then
@@ -6235,14 +6220,17 @@
 	done
 fi
 
-if test -z "${pppd}"; then
-    { echo "$as_me:$LINENO: result: not found" >&5
-echo "${ECHO_T}not found" >&6; }
-    { { echo "$as_me:$LINENO: error: Could not find pppd" >&5
-echo "$as_me: error: Could not find pppd" >&2;}
-   { (exit 1); exit 1; }; }
+if test "xx$pppd_ver" = "xx"; then
+  pppd_ver=${pppd}
+else
+  pppd_ver=`${pppd} --version 2>&1 | grep version | sed 's/pppd version //'`
+fi
+
+# pppd_ver is still null
+if test "xx$pppd_ver" = "xx"; then
+  pppd_ver='2.4.7'
 fi
-pppd_ver=`${pppd} --version 2>&1 | grep version | sed 's/pppd version //'`
+
 { echo "$as_me:$LINENO: result: $pppd ($pppd_ver)" >&5
 echo "${ECHO_T}$pppd ($pppd_ver)" >&6; }
 cat >>confdefs.h <<_ACEOF



diff -Naur orig_accel-pptp-0.8.5/pptpd-1.3.3/Makefile.in accel-pptp-0.8.5/pptpd-1.3.3/Makefile.in
--- orig_accel-pptp-0.8.5/pptpd-1.3.3/Makefile.in	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/Makefile.in	2022-06-20 11:57:33.560160454 +0800
@@ -103,7 +103,8 @@
 AWK = @AWK@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
-CFLAGS = -O2 -fno-builtin -Wall -DSBINDIR='"$(sbindir)"' -I$(kernel_headers)
+CFLAGS = -O2 -fno-builtin -Wall -DSBINDIR='"$(sbindir)"'
+CFLAGS += $(PPTPD_CFLAGS)
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@



diff -urN orig_accel-pptp-0.8.5/pptpd-1.3.3/plugins/Makefile accel-pptp-0.8.5/pptpd-1.3.3/plugins/Makefile
--- orig_accel-pptp-0.8.5/pptpd-1.3.3/plugins/Makefile	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/plugins/Makefile	2023-04-10 14:45:56.939996381 +0800
@@ -1,12 +1,12 @@
-CC	= gcc
+#CC	= gcc
 COPTS	= -O2 -g
 CFLAGS	= $(COPTS) -I.. -I../../include -fPIC
 LDFLAGS	= -shared
 LDADD   = -lutil
 INSTALL	= install -o root
-prefix  = /usr/local
+#prefix  = /usr/local
 
-PLUGINS = pptpd-logwtmp.so
+PLUGINS = pptpd-logwtmp.so
 
 # include dependencies if present
 ifeq (.depend,$(wildcard .depend))
@@ -18,7 +18,7 @@
 %.so: %.c
 	$(CC) -o $@ $(LDFLAGS) $(CFLAGS) $^ $(LDADD)
 
-LIBDIR	?= $(DESTDIR)$(prefix)/lib/pptpd
+LIBDIR	:= $(DESTDIR)$(prefix)/lib/pptpd
 
 install: $(PLUGINS)
 	$(INSTALL) -d $(LIBDIR)

diff -Naur orig_accel-pptp-0.8.5/pptpd-1.3.3/samples/pptpd.conf accel-pptp-0.8.5/pptpd-1.3.3/samples/pptpd.conf
--- orig_accel-pptp-0.8.5/pptpd-1.3.3/samples/pptpd.conf	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/samples/pptpd.conf	2022-06-16 12:33:51.349496495 +0800
@@ -10,6 +10,7 @@
 #	Path to the pppd program, default '/usr/sbin/pppd' on Linux
 #
 #ppp /usr/sbin/pppd
+ppp /bin/pppd
 
 # TAG: option
 #	Specifies the location of the PPP options file.
@@ -98,3 +99,5 @@
 # or
 #localip 192.168.0.234-238,192.168.0.245
 #remoteip 192.168.1.234-238,192.168.1.245
+localip 192.168.2.200
+remoteip 192.168.2.201-210

--- orig_accel-pptp-0.8.5/pptpd-1.3.3/samples/options.pptpd	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/samples/options.pptpd	2022-08-20 09:17:52.502975661 +0800
@@ -20,7 +20,7 @@
 # Strip the domain prefix from the username before authentication.
 # (applies if you use pppd with chapms-strip-domain patch)
 #chapms-strip-domain
-
+linkname ppp3
 
 # Encryption
 # (There have been multiple versions of PPP with encryption support,
@@ -29,15 +29,16 @@
 
 # BSD licensed ppp-2.4.2 upstream with MPPE only, kernel module ppp_mppe.o
 # {{{
-refuse-pap
-refuse-chap
-refuse-mschap
+#refuse-pap
+#refuse-chap
+#refuse-mschap
+require-chap
 # Require the peer to authenticate itself using MS-CHAPv2 [Microsoft
 # Challenge Handshake Authentication Protocol, Version 2] authentication.
-require-mschap-v2
+#require-mschap-v2
 # Require MPPE 128-bit encryption
 # (note that MPPE requires the use of MSCHAP-V2 during authentication)
-require-mppe-128
+#require-mppe-128
 # }}}
 
 
@@ -71,6 +72,7 @@
 # Internet Name Services) server addresses to the clients.  The first
 # instance of this option specifies the primary WINS address; the
 # second instance (if given) specifies the secondary WINS address.
+ms-dns 8.8.8.8
 #ms-wins 10.0.0.3
 #ms-wins 10.0.0.4
 
@@ -80,7 +82,9 @@
 # systems to be on the local ethernet.
 # (you do not need this if your PPTP server is responsible for routing
 # packets to the clients -- James Cameron)
-proxyarp
+#proxyarp
+
+nodeflate
 
 # Normally pptpd passes the IP address to pppd, but if pptpd has been
 # given the delegate option in pptpd.conf or the --delegate command line
@@ -107,7 +111,7 @@
 
 # Create a UUCP-style lock file for the pseudo-tty to ensure exclusive
 # access.
-lock
+#lock
 
 # Disable BSD-Compress compression
 nobsdcomp 
@@ -116,12 +120,12 @@
 # (needed on some networks with Windows 9x/ME/XP clients, see posting to
 # poptop-server on 14th April 2005 by Pawel Pokrywka and followups,
 # http://marc.theaimsgroup.com/?t=111343175400006&r=1&w=2 )
-novj
-novjccomp
+#novj
+#novjccomp
 
 # turn off logging to stderr, since this may be redirected to pptpd, 
 # which may trigger a loopback
-nologfd
+#nologfd
 
 # put plugins here 
 # (putting them higher up may cause them to sent messages to the pty)



diff -Naur orig_accel-pptp-0.8.5/pptpd-1.3.3/samples/chap-secrets accel-pptp-0.8.5/pptpd-1.3.3/samples/chap-secrets
--- orig_accel-pptp-0.8.5/pptpd-1.3.3/samples/chap-secrets	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/samples/chap-secrets	2022-06-15 12:43:47.797494220 +0800
@@ -1,3 +1,6 @@
-# Secrets for authentication using CHAP
-# client	server	secret		IP addresses
-#username	pptpd	password	*
+ # Secrets for authentication using CHAP
+ # client	server	secret		IP addresses
+username	pptpd	password	*
+admin	pptpd	admin	*
+admin	*	admin	*
+test	*	test	*


diff -Naur orig_accel-pptp-0.8.5/pptpd-1.3.3/if_pppox.h accel-pptp-0.8.5/pptpd-1.3.3/if_pppox.h
--- orig_accel-pptp-0.8.5/pptpd-1.3.3/if_pppox.h	1970-01-01 08:00:00.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/if_pppox.h	2022-06-15 11:04:19.040429761 +0800
@@ -0,0 +1,219 @@
+/***************************************************************************
+ * Linux PPP over X - Generic PPP transport layer sockets
+ * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516)
+ *
+ * This file supplies definitions required by the PPP over Ethernet driver
+ * (pppox.c).  All version information wrt this file is located in pppox.c
+ *
+ * License:
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __LINUX_IF_PPPOX_H
+#define __LINUX_IF_PPPOX_H
+
+
+#include <asm/types.h>
+#include <asm/byteorder.h>
+#include <linux/version.h>
+
+#ifdef  __KERNEL__
+#include <linux/in.h>
+#include <linux/if_ether.h>
+#include <linux/if.h>
+#include <linux/netdevice.h>
+#include <linux/ppp_channel.h>
+#endif /* __KERNEL__ */
+
+/* For user-space programs to pick up these definitions
+ * which they wouldn't get otherwise without defining __KERNEL__
+ */
+#ifndef AF_PPPOX
+#define AF_PPPOX	24
+#define PF_PPPOX	AF_PPPOX
+#endif /* !(AF_PPPOX) */
+
+/************************************************************************
+ * PPPoE addressing definition
+ */
+typedef __u16 sid_t;
+struct pppoe_addr{
+       sid_t           sid;                    /* Session identifier */
+       unsigned char   remote[ETH_ALEN];       /* Remote address */
+       char            dev[IFNAMSIZ];          /* Local device to use */
+};
+
+struct pptp_addr{
+       __u16           call_id;
+       struct in_addr  sin_addr;
+};
+/************************************************************************
+ * Protocols supported by AF_PPPOX
+ */
+#define PX_PROTO_OE    0
+#define PX_PROTO_OL2TP 1
+#define PX_PROTO_PPTP  2
+#define PX_MAX_PROTO   3
+
+
+struct sockaddr_pppox {
+       sa_family_t     sa_family;            /* address family, AF_PPPOX */
+       unsigned int    sa_protocol;          /* protocol identifier */
+       union{
+               struct pppoe_addr       pppoe;
+	       			 struct pptp_addr        pptp;
+       }sa_addr;
+}__attribute__ ((packed));
+
+
+/*********************************************************************
+ *
+ * ioctl interface for defining forwarding of connections
+ *
+ ********************************************************************/
+
+#define PPPOEIOCSFWD	_IOW(0xB1 ,0, size_t)
+#define PPPOEIOCDFWD	_IO(0xB1 ,1)
+/*#define PPPOEIOCGFWD	_IOWR(0xB1,2, size_t)*/
+
+/* Codes to identify message types */
+#define PADI_CODE	0x09
+#define PADO_CODE	0x07
+#define PADR_CODE	0x19
+#define PADS_CODE	0x65
+#define PADT_CODE	0xa7
+struct pppoe_tag {
+	__u16 tag_type;
+	__u16 tag_len;
+	char tag_data[0];
+} __attribute ((packed));
+
+/* Tag identifiers */
+#define PTT_EOL		__constant_htons(0x0000)
+#define PTT_SRV_NAME	__constant_htons(0x0101)
+#define PTT_AC_NAME	__constant_htons(0x0102)
+#define PTT_HOST_UNIQ	__constant_htons(0x0103)
+#define PTT_AC_COOKIE	__constant_htons(0x0104)
+#define PTT_VENDOR 	__constant_htons(0x0105)
+#define PTT_RELAY_SID	__constant_htons(0x0110)
+#define PTT_SRV_ERR     __constant_htons(0x0201)
+#define PTT_SYS_ERR  	__constant_htons(0x0202)
+#define PTT_GEN_ERR  	__constant_htons(0x0203)
+
+struct pppoe_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 ver : 4;
+	__u8 type : 4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8 type : 4;
+	__u8 ver : 4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8 code;
+	__u16 sid;
+	__u16 length;
+	struct pppoe_tag tag[0];
+} __attribute__ ((packed));
+
+
+/* Socket options */
+#define PPTP_SO_TIMEOUT 1
+
+
+#ifdef __KERNEL__
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+struct pppoe_opt {
+	struct net_device      *dev;	  /* device associated with socket*/
+	struct pppoe_addr	pa;	  /* what this socket is bound to*/
+	struct sockaddr_pppox	relay;	  /* what socket data will be
+					     relayed to (PPPoE relaying) */
+};
+#endif
+struct pptp_opt {
+	struct pptp_addr	src_addr;
+	struct pptp_addr	dst_addr;
+	__u32 ack_sent, ack_recv;
+	__u32 seq_sent, seq_recv;
+	int ppp_flags;
+};
+#define PPTP_FLAG_PAUSE 0
+#define PPTP_FLAG_PROC 1
+
+#include <net/sock.h>
+
+struct pppox_sock {
+	/* struct sock must be the first member of pppox_sock */
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	struct ppp_channel	chan;
+	struct sock		*sk;
+	#else
+	struct sock		sk;
+	struct ppp_channel	chan;
+	#endif
+	struct pppox_sock	*next;	  /* for hash table */
+	union {
+		struct pppoe_opt pppoe;
+		struct pptp_opt pptp;
+	} proto;
+	unsigned short		num;
+};
+#define pppoe_dev	proto.pppoe.dev
+#define pppoe_pa	proto.pppoe.pa
+#define pppoe_relay	proto.pppoe.relay
+
+static inline struct pppox_sock *pppox_sk(struct sock *sk)
+{
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return (struct pppox_sock *)sk->protinfo.pppox;
+	#else
+	return (struct pppox_sock *)sk;
+	#endif
+}
+
+static inline struct sock *sk_pppox(struct pppox_sock *po)
+{
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return po->sk;
+	#else
+	return (struct sock *)po;
+	#endif
+}
+
+struct module;
+
+struct pppox_proto {
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	int		(*create)(struct socket *sock);
+	#else
+	int		(*create)(struct net *net, struct socket *sock);
+	#endif
+	int		(*ioctl)(struct socket *sock, unsigned int cmd,
+				 unsigned long arg);
+  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+	struct module	*owner;
+	#endif
+};
+
+extern int register_pppox_proto(int proto_num, struct pppox_proto *pp);
+extern void unregister_pppox_proto(int proto_num);
+extern void pppox_unbind_sock(struct sock *sk);/* delete ppp-channel binding */
+extern int pppox_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
+
+/* PPPoX socket states */
+enum {
+    PPPOX_NONE		= 0,  /* initial state */
+    PPPOX_CONNECTED	= 1,  /* connection established ==TCP_ESTABLISHED */
+    PPPOX_BOUND		= 2,  /* bound to ppp device */
+    PPPOX_RELAY		= 4,  /* forwarding is enabled */
+    PPPOX_ZOMBIE	= 8,  /* dead, but still bound to ppp device */
+    PPPOX_DEAD		= 16  /* dead, useless, please clean me up!*/
+};
+
+#endif /* __KERNEL__ */
+
+#endif /* !(__LINUX_IF_PPPOX_H) */

diff -Naur orig_accel-pptp-0.8.5/pptpd-1.3.3/pptpd.c accel-pptp-0.8.5/pptpd-1.3.3/pptpd.c
--- orig_accel-pptp-0.8.5/pptpd-1.3.3/pptpd.c	2022-06-22 17:15:52.593820354 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/pptpd.c	2022-06-22 17:16:34.209292637 +0800
@@ -87,7 +87,7 @@
 static void showversion()
 {
 	printf("accel-pptpd v%s  ", VERSION);
-	printf("compiled for pppd-%s, linux-%s\n",PPPD_VERSION,KERNELVERSION);
+	printf("compiled for %s, %s\n",PPPD_VERSION,KERNELVERSION);
 }
 static void showusage(char *prog)
 {
@@ -152,7 +152,6 @@
 
 	/* open a connection to the syslog daemon */
 	openlog("pptpd", LOG_PID, PPTP_FACILITY);
-	syslog(LOG_ERR, "MGR: Config file not found!");
 
 	/* process command line options */
 	while (1) {
@@ -417,7 +416,7 @@
 	}
 #endif
 
-	syslog(LOG_INFO, "accel-pptpd-%s compiled for pppd-%s, linux-%s\n",VERSION,PPPD_VERSION,KERNELVERSION);
+	syslog(LOG_INFO, "accel-pptpd-%s compiled for %s, %s\n",VERSION,PPPD_VERSION,KERNELVERSION);
 
 	if (!foreground) {
 #if HAVE_DAEMON

--- accel-pptp-0.8.5/pptpd-1.3.3/bcrelay.c.orig	2010-10-06 06:27:46.000000000 -0700
+++ accel-pptp-0.8.5/pptpd-1.3.3/bcrelay.c	2022-11-02 17:39:06.945998031 -0700
@@ -136,6 +136,8 @@
                                 // triggered.
 #define MAX_IFLOGTOSTR 16
 
+#define MAXPORT 16
+
 /* Local function prototypes */
 static void showusage(char *prog);
 static void showversion();
@@ -216,6 +218,50 @@
 static char log_interfaces[MAX_IFLOGTOSTR*MAXIF];
 static char log_relayed[(MAX_IFLOGTOSTR-1)*MAXIF+81];
 static char *ipsec = "";
+static int port_list[MAXPORT] = {0};
+
+static int split_str_to_port(char *argv)
+{
+    char *origStr = argv;
+    char *portStr[MAXPORT+1];
+	int index = 0;
+	while ((portStr[index] =strtok(origStr,","))!= NULL)
+	{
+	    if (index >= MAXPORT)
+	    {
+	        return -1;
+	    }
+		
+	    port_list[index] = atoi(portStr[index]);
+		if (port_list[index] <= 0 || port_list[index] > 65535)
+		{
+		    return -2;
+		}
+			
+	    index++;
+		origStr = NULL;
+	}
+
+	return 0;
+}
+
+static int check_in_port_list(unsigned short port)
+{
+    int index = 0;
+
+	if (!port_list[0])
+		return 1;
+	
+    for (index = 0; index < MAXPORT; index++)
+   	{
+   	    if (port == port_list[index])
+   	    {
+   	        return 1;
+   	    }
+   	}
+	
+	return 0;
+}
 
 static void showusage(char *prog)
 {
@@ -228,6 +274,8 @@
         printf(" [-i] [--incoming <ifin>]  Defines from which interface broadcasts will be relayed.\n");
         printf(" [-n] [--nolog]            No logging/tracing to /var/log/messages.\n");
         printf(" [-o] [--outgoing <ifout>] Defines to which interface broadcasts will be relayed.\n");
+        printf(" [-p] [--destport <p1,p2>] Destination port list. Broadcast packets with destination port in the list will be relayed.\n");
+        printf("                           Maximum of the list is 16.Without define, it means any port.\n");		
         printf(" [-s] [--ipsec <arg>]      Defines an ipsec tunnel to be relayed to.\n");
         printf("                           Since ipsec tunnels terminate on the same interface, we need to define the broadcast\n");
         printf("                           address of the other end-point of the tunnel.  This is done as ipsec0:x.x.x.255\n");
@@ -333,12 +381,13 @@
                         {"help", 0, 0, 0},
                         {"incoming", 1, 0, 0},
                         {"outgoing", 1, 0, 0},
+                        {"destport", 2, 0, 0},
                         {"ipsec", 1, 0, 0},
                         {"version", 0, 0, 0},
                         {0, 0, 0, 0}
                 };
 
-                c = getopt_long(argc, argv, "ndhi:o:s:v", long_options, &option_index);
+                c = getopt_long(argc, argv, "ndhi:o:p:s:v", long_options, &option_index);
                 if (c == -1)
                         break;
                 /* convert long options to short form */
@@ -360,6 +409,15 @@
                 case 'o':
                         ifout = strdup(optarg);
                         break;
+                case 'p':
+                        if(split_str_to_port(optarg) < 0)
+                        {
+                            syslog(LOG_INFO,"Bad syntax: destination port error");
+                            fprintf(stderr, "\nBad syntax: destination port error\n");
+                            showusage(argv[0]);
+                            return 0;                            
+                        }
+                        break;				
                 case 's':
                         ipsec = strdup(optarg);
                         // Validate the ipsec parameters
@@ -381,12 +439,12 @@
                         return 1;
                 }
   }
-  if (ifin == "") {
+  if (*ifin == '\0') {
        syslog(LOG_INFO,"Incoming interface required!");
        showusage(argv[0]);
        _exit(1);
   }
-  if (ifout == "" && ipsec == "") {
+  if (*ifout == '\0' && *ipsec == '\0') {
        syslog(LOG_INFO,"Listen-mode or outgoing or IPsec interface required!");
        showusage(argv[0]);
        _exit(1);
@@ -439,7 +497,7 @@
   /*
    * Open general ethernet socket, only used to discover interfaces.
    */
-  if ((s = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_ALL))) < 0)
+  if ((s = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP))) < 0)
     syslog(LOG_INFO,"%s: Error creating socket", *argv);
 
 
@@ -450,7 +508,7 @@
   memset(cur_ifsnr, -1, sizeof(cur_ifsnr));
   iflist = discoverActiveInterfaces(s);
   for (i=0; iflist[i].index; ++i) {
-    if ((cur_ifsnr[i].sock_nr = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_ALL))) < 0) {
+    if ((cur_ifsnr[i].sock_nr = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP))) < 0) {
       syslog(LOG_ERR, "mainloop: Error, socket error! (rv=%d, errno=%d)", cur_ifsnr[i].sock_nr, errno);
       exit(1);
     }
@@ -520,7 +578,7 @@
         int fsnr = find_sock_nr(old_ifsnr, iflist[i].index);
         if (fsnr == -1) {
           /* found new interface, open dedicated socket and bind it to the interface */
-          if ((cur_ifsnr[i].sock_nr = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_ALL))) < 0) {
+          if ((cur_ifsnr[i].sock_nr = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP))) < 0) {
             syslog(LOG_ERR, "mainloop: Error, socket error! (rv=%d, errno=%d)", cur_ifsnr[i].sock_nr, errno);
             exit(1);
           }
@@ -586,7 +644,7 @@
 
           if ( (ipp_p->ip.protocol == IPPROTO_UDP) &&
                (((ntohl(ipp_p->ip.daddr)) & 0x000000ff) == 0x000000ff) &&
-               (ipp_p->ip.ttl != 1) &&
+               (ipp_p->ip.ttl != 1) &&( check_in_port_list(ntohs(ipp_p->udp.dest)))&&
                (!((*IP_UDPPDU_CHECKSUM_MSB_PTR((unsigned char *)ipp_p+(4*ipp_p->ip.ihl)) == 0) &&
                (*IP_UDPPDU_CHECKSUM_LSB_PTR((unsigned char *)ipp_p+(4*ipp_p->ip.ihl)) == 0))) )
           {
@@ -650,7 +708,7 @@
                   // Update IP checkSum (TTL and src/dest IP Address might have changed)
                   ip_update_checksum((unsigned char *)ipp_p);
                   /* Disable upper layer checksum */
-                  udppdu = (unsigned char *)ipp_p + (4 * ipp_p->ip.ihl);
+                  udppdu = (char*)((unsigned char *)ipp_p + (4 * ipp_p->ip.ihl));
                   *IP_UDPPDU_CHECKSUM_MSB_PTR(udppdu) = (unsigned char)0;
                   *IP_UDPPDU_CHECKSUM_LSB_PTR(udppdu) = (unsigned char)0;
 
@@ -662,7 +720,7 @@
                  * there is no need to concern about the physical/link layer header because it is
                  * filled in automatically (based on the contents of sa).
                  */
-                if ((nrsent = sendto(cur_ifsnr[j].sock_nr, ipp_p, rlen, MSG_DONTWAIT|MSG_TRYHARD, (struct sockaddr *)&sa, salen)) < 0)
+                if ((nrsent = sendto(cur_ifsnr[j].sock_nr, ipp_p, rlen, MSG_DONTWAIT|MSG_DONTROUTE, (struct sockaddr *)&sa, salen)) < 0)
                 {
 		  if (errno == ENETDOWN) {
 		    syslog(LOG_NOTICE, "ignored ENETDOWN from sendto(), a network interface was going down?");
@@ -711,7 +769,7 @@
           int fsnr = find_sock_nr(old_ifsnr, iflist[i].index);
           if (fsnr == -1) {
             /* found new interface, open dedicated socket and bind it to the interface */
-            if ((cur_ifsnr[i].sock_nr = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_ALL))) < 0) {
+            if ((cur_ifsnr[i].sock_nr = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP))) < 0) {
               syslog(LOG_ERR, "mainloop: Error, socket error! (rv=%d, errno=%d)", cur_ifsnr[i].sock_nr, errno);
               exit(1);
             }
@@ -870,7 +928,7 @@
     // IPSEC tunnels are a fun one.  We must change the destination address
     // so that it will be routed to the correct tunnel end point.
     // We can define several tunnel end points for the same ipsec interface.
-    } else if (ipsec != "" && strncmp(ifs.ifc_req[i].ifr_name, "ipsec", 5) == 0) {
+    } else if (*ipsec != '\0' && strncmp(ifs.ifc_req[i].ifr_name, "ipsec", 5) == 0) {
       if (strncmp(ifs.ifc_req[i].ifr_name, ipsec, 6) == 0) {
         struct hostent *hp = gethostbyname(ipsec+7);
         ioctl(s, SIOCGIFINDEX, &ifs.ifc_req[i]);
@@ -983,7 +1041,7 @@
   memset(&sll, 0, sizeof(sll));
   sll.sll_family          = AF_PACKET;
   sll.sll_ifindex         = ifindex;
-  sll.sll_protocol        = htons(ETH_P_ALL);
+  sll.sll_protocol        = htons(ETH_P_IP);
 
   if (bind(fd, (struct sockaddr *) &sll, sizeof(sll)) == -1) {
     syslog(LOG_ERR, "bind_to_iface: Error, bind failed! (rv=-1, errno=%d)", errno);

diff -Naur orig_accel-pptp-0.8.5/pptpd-1.3.3/pptpctrl.c accel-pptp-0.8.5/pptpd-1.3.3/pptpctrl.c
--- orig_accel-pptp-0.8.5/pptpd-1.3.3/pptpctrl.c	2010-10-06 21:27:46.000000000 +0800
+++ accel-pptp-0.8.5/pptpd-1.3.3/pptpctrl.c	2022-08-01 12:17:44.806555269 +0800
@@ -95,6 +95,19 @@
 static int startCall(char **pppaddrs, struct in_addr *inetaddrs);
 static void launch_pppd(char **pppaddrs, struct in_addr *inetaddrs);
 
+#ifdef BCM_PPTPD_LIB_PATH
+#if INTPTR_MAX == INT64_MAX   /* 64-bit platform */
+#define PPTPD_LOGWTMP_SHARED_LIB_PATH  "/lib64/pptpd-logwtmp.so"
+#define PPTP_SHARED_LIB_PATH           "/lib64/pptp.so"
+#else
+#define PPTPD_LOGWTMP_SHARED_LIB_PATH  "/lib/pptpd-logwtmp.so"
+#define PPTP_SHARED_LIB_PATH           "/lib/pptp.so"
+#endif
+#else
+#define PPTPD_LOGWTMP_SHARED_LIB_PATH  "/usr/lib/pptpd/pptpd-logwtmp.so"
+#define PPTP_SHARED_LIB_PATH           "pptp.so"
+#endif
+
 /* Oh the horror.. lets hope this covers all the ones we have to handle */
 #if defined(O_NONBLOCK) && !defined(__sun__) && !defined(__sun)
 #define OUR_NB_MODE O_NONBLOCK
@@ -269,6 +282,10 @@
 
 	struct sockaddr_pppox dst_addr;
 
+#ifdef PPTPD_CTRL_LOG
+	int pptp_ctrl_type;
+#endif
+
 	for (;;) {
 
 		FD_ZERO(&fds);
@@ -318,7 +335,12 @@
 
 		if (FD_ISSET(clientSocket, &fds)) {
 			send_packet = TRUE;
+#ifdef PPTPD_CTRL_LOG
+			pptp_ctrl_type = read_pptp_packet(clientSocket, packet, rply_packet, &rply_size);
+			switch (pptp_ctrl_type) {
+#else
 			switch (read_pptp_packet(clientSocket, packet, rply_packet, &rply_size)) {
+#endif
 			case 0:
 				syslog(LOG_ERR, "CTRL: CTRL read failed");
 				goto leave_drop_call;
@@ -340,6 +362,9 @@
                                 goto leave_drop_call;
 
 			case OUT_CALL_RQST:
+#ifdef PPTPD_CTRL_LOG
+				syslog(LOG_INFO,"CTRL: PPP_PPTP_RECV_OCRQ (case OUT_CALL_RQST), addr is %s\n",inet_ntoa(inetaddrs[1]));
+#endif
 				/* for killing off the link later (ugly) */
 				NOTE_VALUE(PAC, call_id_pair, ((struct pptp_out_call_rply *) (rply_packet))->call_id);
 				NOTE_VALUE(PNS, call_id_pair, ((struct pptp_out_call_rply *) (rply_packet))->call_id_peer);
@@ -392,9 +417,31 @@
 				send_packet = FALSE;
 				break;
 
+#ifdef PPTPD_CTRL_LOG
+			case START_CTRL_CONN_RQST:
+				syslog(LOG_INFO,"CTRL: PPP_PPTP_RECV_START_CCRQ (case START_CTRL_CONN_RQST), addr is %s\n",inet_ntoa(inetaddrs[1]));
+				break;
+#endif
+
 			/* Otherwise, the already-formed reply will do fine, so send it */
 			}
 		}
+		
+#ifdef PPTPD_CTRL_LOG
+		//just do log action
+		// Start-Control-Connection-Reply/Outgoing-Call-Reply
+		if (send_packet == TRUE)
+		{
+			if (pptp_ctrl_type == START_CTRL_CONN_RQST)
+			{
+				syslog(LOG_INFO,"CTRL: PPP_PPTP_SEND_START_CCRP (case START_CTRL_CONN_RQST), addr is %s\n",inet_ntoa(inetaddrs[1]));
+			}
+			else if (pptp_ctrl_type == OUT_CALL_RQST)
+			{
+				syslog(LOG_INFO,"CTRL: PPP_PPTP_SEND_OCRP (case OUT_CALL_RQST), addr is %s\n",inet_ntoa(inetaddrs[1]));
+			}
+		}
+#endif
 
 		/* send reply packet - this may block, but it should be very rare */
 		if (send_packet == TRUE && send_pptp_packet(clientSocket, rply_packet, rply_size) < 0) {
@@ -557,9 +604,19 @@
 {
 	char *pppd_argv[25];
 	int an = 0;
+	int i = 0;
 	sigset_t sigs;
 	char tmp[128];
 
+/* 
+ * FIXBUG: remote client dial pptp vpn server failed
+ * change it from segment level variable to function level variable
+ * it is undefined behavior to access it, that depends on compiler.
+ */
+#if ! BSDUSER_PPP && ! SLIRP
+	char pppInterfaceIPs[33];
+#endif
+    printf("hello\n");
 	pppd_argv[an++] = ppp_binary;
 
 	if (pptpctrl_debug) {
@@ -659,7 +716,6 @@
 	}
 
 	if (*pppaddrs[0] || *pppaddrs[1]) {
-		char pppInterfaceIPs[33];
 		sprintf(pppInterfaceIPs, "%s:%s", pppaddrs[0], pppaddrs[1]);
 		pppd_argv[an++] = pppInterfaceIPs;
 	}
@@ -672,13 +728,17 @@
 
         if (pptp_logwtmp) {
                  pppd_argv[an++] = "plugin";
-                 pppd_argv[an++] = "/usr/lib/pptpd/pptpd-logwtmp.so";
+                 pppd_argv[an++] = PPTPD_LOGWTMP_SHARED_LIB_PATH;
                  pppd_argv[an++] = "pptpd-original-ip";
                  pppd_argv[an++] = inet_ntoa(inetaddrs[1]);
         }
-
+        
+#ifdef PPPD_PPTP_INCLUDED
+	pppd_argv[an++] = "pptp";
+#else
 	pppd_argv[an++] = "plugin";
-	pppd_argv[an++] = "pptp.so";
+	pppd_argv[an++] = PPTP_SHARED_LIB_PATH;
+#endif
 	pppd_argv[an++] = "pptp_client";
 	strcpy(tmp,inet_ntoa(inetaddrs[1]));
 	pppd_argv[an++] = strdup(tmp);
@@ -686,6 +746,9 @@
 	sprintf(tmp,"%u",pptp_sock);
 	pppd_argv[an++] = strdup(tmp);
 	pppd_argv[an++] = "nodetach";
+	
+    for(i = 0 ; i < an ; i++)
+        syslog(LOG_DEBUG, "pppd_argv[%d] = %s", i, pppd_argv[i]);
 
 	/* argv arrays must always be NULL terminated */
 	pppd_argv[an++] = NULL;

--- accel-pptp-0.8.5/pppd_plugin/src/pppd/pppd.h.orig	2010-10-06 06:27:46.000000000 -0700
+++ accel-pptp-0.8.5/pppd_plugin/src/pppd/pppd.h	2022-11-02 17:12:42.105543891 -0700
@@ -54,7 +54,7 @@
 #include <sys/param.h>		/* for MAXPATHLEN and BSD4_4, if defined */
 #include <sys/types.h>		/* for u_int32_t, if defined */
 #include <sys/time.h>		/* for struct timeval */
-#include <net/ppp_defs.h>
+#include <linux/ppp_defs.h>
 
 #if defined(__STDC__)
 #include <stdarg.h>
@@ -208,7 +208,7 @@
 /*
  * Global variables.
  */
-
+extern int use_pptpd_secrets_path;
 extern int	hungup;		/* Physical layer has disconnected */
 extern int	ifunit;		/* Interface unit number */
 extern char	ifname[];	/* Interface name */

--- accel-pptp-0.8.5/pppd_plugin/config.sub.orig	2022-11-02 17:26:25.213000215 -0700
+++ accel-pptp-0.8.5/pppd_plugin/config.sub	2022-11-02 17:00:43.423251181 -0700
@@ -120,7 +120,7 @@
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | linux-musl* |\
   uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os

--- accel-pptp-0.8.5/pptpd-1.3.3/plugins/Makefile.orig	2022-11-03 16:39:40.058897337 -0700
+++ accel-pptp-0.8.5/pptpd-1.3.3/plugins/Makefile	2022-11-03 16:29:33.400584500 -0700
@@ -1,6 +1,6 @@
 #CC	= gcc
 COPTS	= -O2 -g
-CFLAGS	= $(COPTS) -I.. -I../../include -fPIC
+CFLAGS	+= $(COPTS) -I.. -I../../include -fPIC
 LDFLAGS	= -shared
 LDADD   = -lutil
 INSTALL	= install -o root

